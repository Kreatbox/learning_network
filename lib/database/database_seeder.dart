import 'database_helper.dart';

class DatabaseSeeder {
  static Future<void> seedDatabase() async {
    final db = await DatabaseHelper().database;
    // إدراج بيانات عينة للدروس، الاختبارات، والأسئلة
    await db.insert('lessons', {
      'lesson_name': 'الدرس الأول: النياسب 1',
      'lesson_first_title': 'المقدمة',
      'lesson_first_content': '''
إذا أمعن النظر في طبيعة جسم الإنسان، فسوف نلاحظ أنه ينجز الكثير من العمليات في نفس الوقت. فمثلاً، جميع العمليات الأساسية مثل التنفس والهضم والدورة الدموية هي عمليات لا بد لها من أن تتم في الوقت نفسه وبالتوازي، لأنه من غير الممكن أن تنتظر إحدى هذه العمليات انتهاء عملية أخرى.

كذلك، تعمل الحواس الخمس للإنسان في وقت واحد، حيث يمكن له أن يسمع ويشاهد، مثلاً، في نفس الوقت. وعلى غرار ذلك، إذا أمعنا النظر في الحاسب وكيفية قيامه بعملياته الأساسية، سنلاحظ أنه قادر على تنفيذ برنامج ما واستبيان بريد إلكتروني من الشبكة وتنفيذ أمر إدخال وإخراج (مثل الطباعة) في نفس الوقت وبشكل متوازي.

يستخدم الحاسب بشكل عام عند إنجازه لعدد من العمليات بشكل متوازي ميزة تعددية النياسب (Multithreading). فإذا افترضنا، مثلاً، وجود ثلاث عمليات مختلفة تتطلب التنفيذ من قبل الحاسب في نفس الوقت، يقوم الحاسب بإنشاء ثلاثة نياسب (Threads)، بحيث يكون كل نيسب مسؤولاً عن تنفيذ عملية معينة، ويتم تنفيذ النياسب الثلاثة في نفس الوقت. إذ أنه من غير المنطقي أن تقتصر معالجة الحاسب على عملية واحدة فقط في وقت معين وتبقى جميع العمليات الأخرى معلقة حتى انتهاء هذه العملية.

لإيضاح أهمية تعددية النياسب، لنناقش المثال التالي: عندما يقوم المستخدم بتحميل برنامج أو ملف معين من الإنترنت (مثل مقطع صوتي أو مقطع فيديو)، قد يطلب المستخدم تشغيل المقطع قبل انتهاء التحميل كاملاً. يحل الحاسب هذه المشكلة باستخدام ميزة تعددية النياسب، حيث يقوم نيسب بتحميل المقطع بينما يقوم نيسب آخر بتشغيله. 

وهنا يطرح السؤال التالي: ماذا سيحدث إذا وصل نيسب التشغيل إلى جزء لم يحمله نيسب التحميل بعد؟ يكمن الحل في ما يسمى بمزامنة النياسب (Threads Synchronization).

ومن المثير للدهشة أنه رغم الفوائد الواضحة لتعددية النياسب، لم يكن من السهل توظيف هذه الميزة وبناؤها في الماضي، لأن لغات البرمجة القديمة لم تقدم الأدوات اللازمة للتعامل مع النياسب. وكانت هذه الميزة محصورة على متخصصي برمجة النظم فقط. أدركت وزارة الدفاع الأمريكية أهمية تعددية النياسب، فطورت لغة البرمجة Ada التي استخدمتها لخدمة مصالحها، إلا أنها لم تكن واسعة الاستخدام في المجال التعليمي أو التجاري.

بعد ذلك، ومنذ فترة قريبة، قامت بيئة العمل .NET بتزويد جميع لغات البرمجة الموجودة ضمنها بالأدوات التي تمكن المبرمجين من بناء النياسب والتعامل معها، ووضعت هذه الأدوات في المكتبة System.Threading.

سنتحدث في هذا الفصل عن النياسب، وكيف يتم بناؤها والتعامل معها برمجياً، وكيفية توظيف ميزة تعددية النياسب.
<image>
''',
      'lesson_first_image': 'assets/images/empty.jpg',
      'lesson_second_title': 'دورة حياة النياسب',
      'lesson_second_content': '''
بعد أن تحدثنا بشكل عام عن مفهوم النيسب، سوف نتحدث بالتفصيل عن النياسب ودورة حياتها في .NET. سوف نتعرف على حالات النياسب (Threads States) وكيفية الانتقال فيما بينها. من الجدير بالذكر هنا أن مكتبة System.Threading تحتوي على الصنفين Thread وMonitor، اللذين يحتويان على الطرق اللازمة للتحكم في النياسب والتعامل معها.

تبدأ دورة حياة النيسب من حالة عدم الانطلاق (Unstarted)، وذلك عندما يتم إنشاؤه بعد تمرير المفوض (Delegate) إلى مُنشئ النيسب (Thread Constructor). يحدد هذا المفوض المهام التي يجب أن يقوم بها النيسب خلال فترة حياته، ويكون عبارة عن طريقة تعيد لا شيء (void) وليس لها معاملات (parameters).

يبقى النيسب في الحالة الابتدائية (Unstarted) حتى يقوم البرنامج باستدعاء الطريقة (Start)، والتي تقوم بتغيير حالة النيسب إلى حالة التشغيل (Running). بعد ذلك، يُعاد التحكم مباشرة إلى التعليمة التالية في البرنامج بعد التعليمة التي استدعت الطريقة (Start).

يمكن في هذه المرحلة أن تُنفذ النياسب الموجودة في حالة التشغيل بشكل متزامن في نظام المعالجات المتعددة، أو تشارك النياسب في التنفيذ في نظام المعالج الوحيد. لاحظ أنه ليس بالضرورة أن ينفذ النيسب باستمرار إلا عندما يُسند إلى المعالج.

يدخل النيسب في حالة الإيقاف أو الإحباط (Stopped or Aborted) عندما ينهي النيسب المهمة الموكلة إليه بشكل طبيعي، أو عندما يجبر البرنامج النيسب على ذلك باستدعاء طريقة الإحباط أو الإنهاء المفاجئ (Abort)، والتي تُدخل النيسب في حالة طلب الإحباط (Requested Abort)، حيث لا يتم إنهاء النيسب فعليًا إلا بعد استقبال استثناء إحباط النيسب (ThreadAbortException). بعد ذلك يقوم جامع النفايات (Garbage Collector) بإزالة النيسب من الذاكرة ما لم تُسند إليه مهمة أخرى.

من المهم ملاحظة أنه عندما يكون النيسب في حالة أخرى غير حالة التشغيل، سوف يبقى في حالته الحالية ويدخل في حالة طلب الإحباط (Requested Abort) في الوقت نفسه، ولكنه لن يستجيب لاستثناء (ThreadAbortException) إلا بعد أن يخرج من حالته الحالية.

<image>

يُعتبر النيسب مجمدًا (Blocked) عندما يكون عاجزًا عن استخدام أي معالج حتى وإن كان متاحًا. على سبيل المثال، يصبح النيسب مجمدًا عندما تكون مهمته تتعلق بطلب دخل/خرج، حيث يقوم نظام التشغيل بحجبه ومنعه من متابعة التنفيذ حتى يتمكن نظام التشغيل من إنجاز طلب الدخل/الخرج الذي ينتظره النيسب. بعد ذلك، يعود النيسب إلى حالة التشغيل ويمكن أن يعاود التنفيذ.

أحد الأمثلة الأخرى على تجميد النيسب هو في حالة مزامنة النياسب. عندما يبدأ النيسب المزامنة، يجب أن يحصل على قفل معين كما سنرى لاحقًا عند استدعاء الطريقة (Enter) الموجودة في الصنف Monitor. إذا لم يكن القفل متاحًا، سيصبح النيسب مجمدًا حتى يتاح القفل المطلوب. يجب ملاحظة أن حالة التجميد ليست حالة حقيقية في بيئة العمل .NET، بل هي مفهوم أو تعبير يُطلق على النيسب عندما لا يكون في حالة التشغيل.

يمكن أن يصل النيسب إلى حالة الانتظار (Join, Sleep, Wait) بثلاث طرق:

الطريقة الأولى: عندما يواجه النيسب تعليمة لا يمكن تنفيذها حاليًا كأن تتطلب التعليمة حالة لم تتحقق بعد، مثل استدعاء الطريقة (Wait) من الصنف Monitor. في هذه الحالة، يدخل النيسب في حالة الانتظار (Wait). بعد ذلك، يعود النيسب إلى حالة التشغيل عندما يستدعي نيسب آخر طريقة الإنعاش (Pulse) أو الإنعاش الكلي (PulseAll) من الصنف Monitor. لاحظ أن طريقة الإنعاش (Pulse) تُغير حالة النيسب المنتظر التالي إلى حالة التشغيل، بينما تقوم طريقة (PulseAll) بتغيير حالات جميع النياسب المنتظرة إلى حالة التشغيل.

الطريقة الثانية: يمكن للنيسب الموجود في حالة التشغيل أن يستدعي طريقة السبات (Sleep) ليدخل في حالة انتظار لمدة زمنية محددة، تُعرف بالميلي ثانية، تُمرر كمعامل للطريقة (Sleep). يعود النيسب من حالة السبات إلى حالة التشغيل عندما ينتهي وقت السبات. لاحظ أن النيسب الذي يكون في حالة السبات لا يمكنه استخدام المعالج حتى وإن كان متاحًا.

الطريقة الثالثة: من الممكن أن يعتمد تنفيذ نيسب على نيسب آخر. في هذه الحالة، يدخل النيسب في حالة انتظار (Join, Sleep, Wait) حتى يستدعي النيسب الآخر الطريقة (Join)، والتي تربط النياسبين وتضمّهما. بعد ذلك، يخرج النيسب من هذه الحالة.

يمكن أن تعود النياسب الموجودة في حالة الانتظار (Wait) أو السبات (Sleep) إلى حالة التشغيل عندما يستدعي نيسب آخر في البرنامج طريقة المقاطعة (Interrupt)، والتي تقوم بإرسال استثناء مقاطعة النيسب (ThreadInterruptedException) إلى النيسب الأول.

عندما يتم استدعاء طريقة الإيقاف المؤقت (Suspend)، ستنتقل حالة النيسب من التشغيل إلى الإيقاف المؤقت. ويمكن إعادة النيسب إلى حالة التشغيل مرة أخرى عندما يستدعي البرنامج طريقة الاستئناف أو المتابعة (Resume).

في الواقع، عندما تستدعى طريقة الإيقاف المؤقت (Suspend)، يدخل النيسب فعليًا في حالة طلب الإيقاف المؤقت (Requested Suspend). إذا كان النيسب في حالة (Join, Sleep, Wait) أو حالة التجميد عند استدعاء طلب الإيقاف المؤقت، سيبقى النيسب في حالته السابقة وفي حالة انتظار الإيقاف المؤقت (Requested Suspend). لا يمكن للنيسب الاستجابة لطلب الإيقاف المؤقت تمامًا إلا بعد أن يخرج من حالته الحالية. سنتحدث لاحقًا عن كيفية التحويل إلى هذه الحالة بالتفصيل في سياق مزامنة النياسب.

بشكل مختصر، يبقى النيسب في حالة التشغيل إلا إذا صادفته إحدى الحالات التالية:
A. أن يصل إلى النهاية ويكمل مهمته.
B. أن يُجمّد بسبب عمليات دخل/خرج أو لأي سبب آخر.
C. أن يُحوّل إلى حالة السبات أو أن يستدعي من الصنف Monitor الطرق (Wait, Join, Sleep).
D. أن يتسبب نيسب آخر ذو أولوية أعلى في إيقاف عمله مؤقتًا.
E. انتهاء الكمّة الزمنية (Quantum) المخصصة له.
F. يمكن أن يعمل النيسب ويُحوّل إلى حالة التشغيل، رغم وجود نيسب آخر في حالة التشغيل، وذلك بتأجيل عمل النيسب الآخر في الحالات التالية:
    - إذا تم إعادة نيسب إلى حالة التشغيل بعد أن كان في حالة السبات.
    - إذا انتهت معالجة عمليات دخل/خرج كان النيسب قد جُمد بسببها.
    - إذا تم استدعاء طرق الإنعاش (Pulse) أو (PulseAll) والنيسب كان في حالة الانتظار.
    - عندما يعود نيسب للعمل بعد خروجه من حالة الإيقاف المؤقت.
    - أو بعد انتهاء تنفيذ نيسب ذو أولوية أعلى من النيسب الحالي.
''',
      'lesson_second_image': 'assets/images/lesson_1_second_image.jpg',
      'lesson_link': 'https://www.youtube.com/watch?v=9ANSu9Cg-Bo'
    });
    await db.insert('lessons', {
      'lesson_name': 'الدرس الثاني: النياسب 2',
      'lesson_first_title': 'أفضليات تنظيم النياسب',
      'lesson_first_content': '''
يملك النيسب درجة أفضلية معينة (Priority) من بين الأفضليات المتوفرة في تعداد (Thread Priority enumeration). تتراوح درجات هذه الأفضليات بين:

1. أفضلية دنيا (Lowest)
2. أقل من الطبيعي (Below Normal)
3. طبيعي (Normal)، وهو الوضع الافتراضي للنياسب.
4. فوق الطبيعي (Above Normal)
5. أفضلية عليا (Highest)

يدعم نظام التشغيل Windows ميزة اقتسام الوقت (Time Slicing)، التي تتيح للنياسب ذات الأولوية المتساوية فرصة مشاركة المعالج. لاحظ أنه بدون هذه الميزة، سيعمل النيسب حتى انتهاء عمله إلا إذا تغيرت حالته عن حالة التشغيل، دون إعطاء فرصة للنياسب الأخرى التي تملك نفس الأولوية بالتنفيذ. أما مع ميزة تجزئة الوقت، فيُخصص لكل نيسب وقت معين من وقت المعالج يُسمى الكمة (Quantum)، يمكن أن ينفذ خلالها النيسب جزءًا من عمله. عند انتهاء الكمة المخصصة لنيسب، يُمنع هذا النيسب من استخدام المعالج، وتنتقل الفرصة أو الكمة إلى نيسب آخر إذا كان موجودًا، حتى لو لم ينتهِ عمل النيسب الأول.

يتلخص عمل مجدول النياسب (Thread Scheduler) في الحرص على أن تكون النياسب ذات الأولوية الكبرى في حالة التشغيل دائمًا. إذا وجد أكثر من نيسب له الأولوية الكبرى، يعمل مجدول النياسب على ضمان عملها بطريقة تُسمى "روبن الدائرية" (Round-Robin Fashion).

يبين الشكل التالي تعدد مستويات الأولوية للنياسب بافتراض أنها تعالج في حاسب ذو معالج وحيد. تُعالج النياسب A وB بطريقة روبن الدائرية حتى تنتهي مهمة كل منهما. أي أن النيسب A سيأخذ وقتًا للعمل، ثم يأخذ النيسب B وقتًا آخر، ثم يعود النيسب A ليأخذ مهمة أخرى، وهكذا حتى ينتهي عملهما.

بعد ذلك، يُخصص المعالج كل طاقاته للنياسب المتبقية في الأولويات الأدنى، إلا إذا بدأ عمل نيسب آخر في نفس الأولوية الأعلى. يعمل النيسب C حتى ينتهي، ثم تعمل النياسب D وE وF بنفس الطريقة الدائرية حتى تنتهي من التنفيذ.

من المهم ملاحظة أن الاعتماد على نظام التشغيل في جدولة النياسب وتنفيذها حسب أولويتها يمنح النياسب الجديدة ذات الأولوية الكبرى القدرة على تأجيل تنفيذ النياسب ذات الأولوية الدنيا. هذا التأجيل غير المحدود في بعض الأحيان قد يؤدي إلى تقليل فرص النياسب ذات الأولوية الدنيا في التنفيذ، وقد يصل إلى مرحلة عدم التنفيذ إطلاقًا.

يمكن ضبط وتعيير أولوية النياسب من الخاصية (Priority)، التي تأخذ قيمها من مجموعة التعداد (Thread Priority). إذا تم تعريف قيمة غير معرفة ضمن هذا التعداد، سيظهر استثناء أو خطأ في القيمة التي تم تمريرها (ArgumentException).

<image>
''',
      'lesson_first_image': 'assets/images/empty.jpg',
      'lesson_second_title': 'مزامنة النياسب :Synchronization Thread',
      'lesson_second_content': '''
إذا كانت لدينا عدة نياسب تتشارك في استخدام نفس البيانات، يمكن لهذه النياسب أن تقرأ هذه البيانات أو تصل إلى جزء منها دون أي مشكلة. ولكن عندما تتشارك عدة نياسب في بيانات معينة وتقوم بتعديلها، قد تحدث مشاكل تضارب (collision) ما لم يتم مزامنة النياسب التي تشترك في هذه البيانات.

على سبيل المثال، لنفترض وجود نيسبين يقومان بتحديث بيانات معينة في وقت واحد ولكن لم تتم مزامنتهما. في هذه الحالة، سيتم تحديث البيانات بواسطة النيسب الأخير، مع تجاهل ما قام به النيسب الأول من تعديلات. وإذا كانت هذه البيانات تمثل مصفوفة أو أي بنية معطيات أخرى، بحيث تتمكن النياسب من تحديث أجزاء من هذه البيانات بشكل منفصل في نفس الوقت، فمن الممكن أن نلاحظ أن جزءًا من هذه البيانات يعكس بيانات من نيسب بينما يعكس الجزء الآخر بيانات من نيسب آخر. هذا يجعل من الصعب جدًا على البرنامج أن يتأكد متى تم تحديث هذه البيانات.

يتم حل هذه المشاكل من خلال مزامنة النياسب (Synchronization) التي ترغب في مشاركة بيانات معينة لقراءتها والتعديل عليها. المقصود بالمزامنة هنا هو إعطاء الإمكانية لنيسب واحد فقط لمعالجة البيانات والسماح له بالتأثير فيها بشكل حصري (exclusive). خلال هذا الوقت، تكون النياسب الأخرى في حالة انتظار. وعندما ينتهي النيسب المتحكم في البيانات، تُمنح الفرصة لأحد النياسب المنتظرة للتعامل معها. بهذه الطريقة، سيتعامل كل نيسب مع البيانات بشكل حصري وستُمنع النياسب الأخرى من التعامل مع البيانات في نفس الوقت.

يقدم الصف (Monitor) عددًا من الطرق التي تمكن من مزامنة النياسب (مشاركة نياسب متعددة لبيانات معينة). عندما يحتاج نيسب معين إلى التعامل مع غرض بشكل حصري، يجب أن يستدعي هذا النيسب الطريقة (Enter) من الصف (Monitor). تقوم هذه الطريقة بتثبيت قفل على الغرض بحيث يمكن لنيسب واحد فقط التعامل معه. لكل غرض خاصية (Block Sync) التي تحدد حالة قفل الغرض. إذا طلب نيسب آخر التعامل مع غرض مقفل، فإنه يجمد (Blocked).

عندما ينتهي النيسب من التعامل مع الغرض، ينفذ الطريقة (Exit) لتحرير الغرض من القفل. يتم تحديث حالة قفل الغرض (Block Sync) لتشير إلى أنه أصبح حرًا ومتاحًا من جديد. إذا كان هناك نيسب في حالة التجميد، فسوف يعاد إلى حالة التشغيل وتُكرر العمليات السابقة، وهكذا حتى تنتهي جميع النياسب التي ترغب في التعامل مع الأغراض نفسها.

من الضروري الانتباه إلى الأخطاء البرمجية الشائعة التالية:
- يجب التأكد من أن جميع التعليمات التي تعمل على تعديل الغرض تطلب قفل الغرض قبل التعامل معه.
- تظهر حالة (Deadlock) عندما لا يتمكن نيسب ما من التنفيذ بسبب انتظاره لنيسب آخر، وفي نفس الوقت لا ينفذ النيسب الثاني لأنه في انتظار تنفيذ النيسب الأول، مما يعني أن هناك نيسبين في انتظار بعضهما البعض.
- لا يمكن لنيسب في حالة انتظار / سبات / ضم أن يعود إلى حالة التشغيل ليكمل تنفيذ مهمته، إلا إذا قام نيسب آخر باستدعاء طريقة الإنعاش (Pulse) أو إنعاش الكل (Pulse All)، وإلا سيبقى النيسب منتظرًا، وهو ما يشبه عمليًا حالة (Deadlock).

يمكن تطبيق المفهوم السابق عمليًا في (C#) باستخدام القفل على الغرض المراد. يتم وضع الغرض المراد قفله كمدخل للطريقة، مثلاً: 

lock (objectReference) {
    // التعليمات التي تطلب المزامنة تُكتب هنا
}
تمنح التعليمة السابقة قفلًا للنيسب الذي يريد التعامل مع الغرض الذي مُرر مرجعه بين الأقواس، ويدخل الغرض ذاته في وضع حظر القفل، مما يمنع أي نيسب آخر من الحصول على قفل على نفس الغرض. يكون مرجع الغرض هو نفسه الذي يُمرر عادة إلى طرائق الصف (Monitor) مثل الدخول، والخروج، والإنعاش.

عند انتهاء وضع حظر القفل لأي سبب، يُحرر (C#) الغرض من القفل الذي كان قد مُنح للنيسب. على سبيل المثال، عندما يتوقف عمل النيسب الذي يملك القفل بانتظار تحقق شرط معين ويدخل في حالة الانتظار، سوف يُحرر الغرض من القفل. وعند تحقق الشروط التي ينتظرها النيسب ويعود إلى حالة التشغيل، يمكنه إعادة طلب القفل على الغرض ليكمل مهمته.

يجب ملاحظة الفرق بين أن يكون النيسب في حالة التجميد وليس في حالة الانتظار، وأن يكون في حالة انتظار / ضم / سبات عمليًا بانتظار تحقق شرط معين. ''',
      'lesson_second_image': 'assets/images/empty.jpg',
      'lesson_link': 'https://www.youtube.com/watch?v=9ANSu9Cg-Bo'
    });
    await db.insert('lessons', {
      'lesson_name': 'الدرس الثالث: برمجة التطبيقات الشبكية زبون/مخدم',
      'lesson_first_title': 'المقدمة',
      'lesson_first_content': '''
يمنح التعامل مع شبكة الإنترنت وعالم الويب الكثير من الإمكانيات، لما تُقدمه من خدمات متنوعة، بالإضافة إلى القدرة على الحصول على المعلومات من أي مكان في العالم. كما تساهم الشبكات في تحسين الأداء من خلال مشاركة البيانات عبر شبكة الإنترنت.

تُعتبر المكتبة البرمجية (Framework Class Library - FCL) الخاصة بـ .NET هي الأداة الأساسية التي تساعد في تطوير تطبيقات الويب وتطبيقات الإنترنت. من خلالها، يمكن للبرامج البحث عن المعلومات في جميع أنحاء العالم، ومشاركة البيانات مع أجهزة أخرى في مناطق بعيدة.

سنقوم في الفصل القادم بدراسة خدمات الويب (Web Services) المستخدمة في بناء التطبيقات الموزعة، وذلك على مستوى عالٍ. سنبدأ بالتطرق إلى تقنيات الاتصالات المستخدمة في نقل البيانات عبر شبكة الإنترنت، ثم نشرح الطرق الأساسية لإقامة اتصال بين تطبيقين يستخدمان أساليب تدفق البيانات.

سنناقش الاتصال المرتبط (Connection-Oriented) الذي يمكّن برنامجين من التواصل ونقل البيانات، بالإضافة إلى طرق القراءة والكتابة من وإلى الملفات. بعد ذلك، سنعالج تطبيق محادثة (Chatting) يستخدم هذه التقنيات لتبادل الرسائل بين الزبون والخادم.

سنتناول أيضًا تقنيات الاتصال غير المرتبط (Connectionless) لنقل البيانات بين التطبيقات، والتي تتسم بكونها أقل موثوقية مقارنة بالاتصال المرتبط. سنستعرض تطبيقات تعتمد على هذه التقنية في نقل البيانات، مثل البث المباشر عبر الإنترنت.

سنركز بعد ذلك على مكون التحكم الجديد (Web Browser)، الذي يعد ضروريًا للتفاعل مع التطبيقات التي تستخدم الويب. وسنختتم الفصل بالحديث عن تقنية الشبكات عن بُعد (Remoting) في .NET، التي توفر خدمات مشابهة لخدمات الويب، مما يسمح بتنفيذ عمليات المعالجة الموزعة عبر الشبكة.
''',
      'lesson_first_image': 'assets/images/empty.jpg',
      'lesson_second_title':
          'مقارنة بين الاتصال المرتبط (Connection-Oriented Communication) والاتصال عديم الارتباط (Connectionless Communication)',
      'lesson_second_content': '''
الاتصال بين التطبيقات: الاتصال المرتبط والاتصال عديم الارتباط

توجد طريقتان رئيسيتان لتحقيق الاتصال بين التطبيقات:

الاتصال المرتبط (Connection-Oriented Communication): يشبه هذا النوع من الاتصال الشبكة الهاتفية، حيث يتم تأسيس الاتصال والحفاظ عليه مفتوحًا حتى انتهاء التواصل من قِبل أحد الطرفين. يبقى الاتصال مفتوحًا لنقل المعلومات بين الطرفين. في الاتصال المرتبط، يتم إرسال معلومات تحكم بين الحواسيب لتفعيل الاتصال بين الطرفين، وتعرف هذه التقنية بالمصافحة (Handshaking). يعتبر الاتصال المرتبط موثوقًا حيث يتم ضمان توصيل الرزم (Packets) بدون فقدان أو تكرار، كما يتم تجميع البيانات بالترتيب الصحيح.

الاتصال عديم الارتباط (Connectionless Communication): يشبه هذا النوع من الاتصال الخدمة البريدية، حيث يمكن إرسال الرسائل من موقع إلى آخر عبر مسارات مختلفة وفي أوقات مختلفة، وقد تتأخر أو تفقد بعض الرزم أثناء النقل. في الاتصال عديم الارتباط، لا يتم تأسيس اتصال مسبق. تُرسل البيانات في رزم يمكن أن تتبع مسارات متعددة، وقد تصل الرزم تالفة أو في ترتيب غير صحيح. يُعتبر هذا النوع من الاتصال غير موثوق، لأنه لا يضمن توصيل البيانات بشكل دقيق.

الملخص: يعتمد اختيار نوع الاتصال على متطلبات التطبيق. إذا كانت الموثوقية والتسلسل من الأولويات، فإن الاتصال المرتبط يكون الخيار المناسب. بينما إذا كانت السرعة والكفاءة هي الأكثر أهمية، فإن الاتصال عديم الارتباط قد يكون الأفضل. الشبكة (مثل الإنترنت) تعتبر شبكة غير موثوقة، مما يعني أن المعلومات والبيانات المرسلة عبرها يمكن أن تفقد أو تتعطل أثناء عملية النقل.
''',
      'lesson_second_image': 'assets/images/empty.jpg',
      'lesson_link': 'https://www.youtube.com/watch?v=9ANSu9Cg-Bo'
    });
    await db.insert('lessons', {
      'lesson_name': 'الدرس الرابع: نقل البيانات',
      'lesson_first_title': 'بروتوكولات نقل البيانات ',
      'lesson_first_content': '''
هناك العديد من البروتوكولات لنقل البيانات التي تحدد كيفية الاتصال بين التطبيقات. يمكن تعريف البروتوكول بأنه مجموعة من القواعد التي تحكم كيفية تبادل البيانات بين مكونين (يمكن أن تكون هذه المكونات عبارة عن حواسب).

سنقوم في هذا الفصل بالتركيز على بروتوكول التحكم في النقل (Transmission Control Protocol - TCP) المستخدم لنقل البيانات بشكل موثوق، وبروتوكول بيانات المستخدم (User Datagram Protocol - UDP).

توفر .NET إمكانيات التعامل مع البروتوكولات TCP وUDP ضمن فئة الأسماء System.Net.Sockets. يعتبر البروتوكول TCP بروتوكولًا مرتبطًا لأنه يضمن توصيل البيانات بشكل موثوق. يُستخدم البروتوكول TCP في العديد من البروتوكولات العليا مثل بروتوكول HTTP لتبادل المعلومات عبر شبكة الإنترنت بطريقة آمنة، حيث يقوم البروتوكول TCP بإعادة إرسال رزم البيانات في حال فقدانها وعدم وصولها إلى الوجهة المقصودة. كما يمكنه تجميع الرزم بالتسلسل الصحيح وبصورة واضحة للتطبيق المستلم، بالإضافة إلى استبعاد الرزم المكررة.

في المقابل، يُستخدم الاتصال عديم الارتباط (UDP) من قبل التطبيقات التي لا تتطلب تبادل معلومات موثوق بين الطرفين. يُمكن البروتوكول UDP من الحد الأدنى من نقل البيانات دون الحاجة إلى التأكيد على عملية الاتصال بين التطبيقات. لا يقدم البروتوكول UDP ضمانًا لوصول رزم البيانات، والتي تُسمى برقيات البيانات (Datagrams)، إلى الوجهة المقصودة، ولا يأتي ترتيب وصولها كما أرسلت.

على الرغم من عدم موثوقية UDP، فإن له فوائد عدة يمكن الحصول عليها عند استخدامه بدلاً من TCP. فعند استخدام البروتوكول UDP، تشكّل عملية نقل البيانات بين طرفي الاتصال حملاً أقل على الشبكة، حيث لا تحتاج رزم البيانات إلى حمل معلومات التحكم التي يحتاجها البروتوكول TCP لضمان موثوقية وصول المعلومات. في حال عدم وصول البيانات، يمكن استخدام البروتوكول UDP في حالات معينة، مثل الحوارات العملية في بيئات تحتاج إلى سرعة عالية، حيث تكون الموثوقية غير مطلوبة في بعض الأحيان.

بعض التطبيقات، مثل نقل الصوت والفيديو، يمكن أن تتسامح مع فقدان بعض برقيات البيانات، وفي هذه الحالات يكون استخدام البروتوكول UDP أكثر فعالية. إذا استخدمت التطبيقات البروتوكول TCP، فإن فقدان أي جزء من البيانات قد يؤدي إلى توقف كبير وتأخير في تشغيل التطبيق، حيث يجب إعادة إرسال الجزء المفقود عند النقل أو استقباله لاستمرار عمل التطبيق.

إضافة إلى ذلك، يمكن لبعض التطبيقات الحاسوبية والتي تحتاج إلى تقنيات موثوقية خاصة أن تقوم بتطوير بروتوكولات تعتمد على UDP لتوفير أداء أفضل.
''',
      'lesson_first_image': 'assets/images/empty.jpg',
      'lesson_second_title':
          'بناء مخدم TCP باستخدام مقابس تدفق البيانات (Sockets Stream)',
      'lesson_second_content': '''
بناء مخدم TCP باستخدام مقابس تدفق البيانات (Sockets Stream) يقوم المخدم عادةً باستقبال الطلبات من الزبائن، ويحتوي برنامج المخدم على كتل برمجية تعمل بشكل مستمر لتقبل الطلبات عند وصولها إلى المخدم. يقوم المخدم بإنشاء اتصال مع الزبون، وبعد ذلك يستخدم هذا الاتصال لمعالجة الطلبات المستقبلة وإرسال المعلومات إليه. يتم إدارة الاتصالات من خلال استخدام الكائن (Socket)، حيث يقوم البروتوكول TCP بمعالجة البيانات التي تُستقبل وتُرسل كتيار من البايتات (Bytes).

يتطلب إنشاء مخدم TCP استخدام مقابس تدفق البيانات (Sockets Stream)، ويتضمن ذلك عدة مراحل:

المرحلة الأولى: إنشاء الكائن Listener  
يجب أولاً إنشاء كائن من النوع TCPListener باستخدام نظام الأسماء (System.Net.Sockets). هذا الكائن يستمع للطلبات المرسلة إليه. يتم إنشاء كائن جديد من النوع TCPListener كما يلي:
TCPListener server = new TCPListener(IPAddress.Any, port);
حيث يتم ربط تطبيق المخدم برقم منفذ محدد (port). يمكن أن يتراوح هذا الرقم بين 0 و65535، إلا أن الأرقام الأقل من 1024 محجوزة عادةً لخدمات معروفة مثل خدمات الويب والبريد الإلكتروني.

المرحلة الثانية: بدء الاستماع لطلبات الاتصال
يجب استدعاء الطريقة Start من الكائن TCPListener ليبدأ في الاستماع لطلبات الاتصال.

المرحلة الثالثة: تأسيس الاتصال بين المخدم والزبون
يبقى المخدم مستمراً في الاستماع للطلبات المرسلة إليه، حتى يقوم أحد الزبائن بمحاولة الاتصال. بعد أن ينشئ المخدم اتصالاً، يتعامل الكائن Socket مع الاتصال مع الزبون. تُستخدم الطريقة AcceptSocket من الكائن TCPListener لقبول الطلب، وتعيد كائنًا من النوع Socket يمثل الاتصال الجديد:
Socket connection = server.AcceptSocket();
عندما يستقبل المخدم طلب اتصال من عميل، يقوم باستدعاء الدالة Accept من كائن TCPListener لجعل الاتصال مفعلًا. تخفي هذه الدالة في لغة C# التفاصيل المعقدة التي تتم على مستوى الشبكة عن المبرمج، مما يتيح له كتابة كود بسيط وفعّال في برنامج المخدم.

المرحلة الرابعة: معالجة الاتصالات
يغطي هذا القسم استقبال وإرسال الطلبات والمعلومات بين المخدم والعميل عبر الدالتين Send وReceive من كائن Socket. يجب ملاحظة أن هاتين الدالتين يمكن استخدامهما فقط في حالة وجود اتصال ثابت بين المخدم والعميل. أما في حالة استخدام بروتوكولات البيانات مثل UDP، يمكن استخدام دوال SendTo وReceiveFrom في حالة عدم وجود اتصال ثابت.

المرحلة الخامسة: إنهاء الاتصال
عند انتهاء المخدم والعميل من عملية استقبال وإرسال البيانات، يستخدم المخدم الدالة Close من كائن Socket لإنهاء الاتصال بشكل صحيح. بعد الانتهاء من الاتصال، يعود المخدم إلى حالة الانتظار لاستقبال اتصالات جديدة من قبل العملاء.

معالجة مشكلات الاتصال
توجد مشكلة شائعة عند استخدام طرق الاتصال المتزامنة، حيث قد تتسبب في حجب الطلبات الأخرى أثناء معالجة الطلبات الحالية، مما يعني أن العملاء الآخرين قد لا يتمكنون من الاتصال بالمخدم في الوقت الذي يكون فيه مشغولًا بمعالجة طلبات سابقة. لحل هذه المشكلة، يجب استخدام البرمجة متعددة الخيوط (Multi-threading). عند استقبال اتصال جديد من قبل المخدم، يقوم بإنشاء خيط (Thread) جديد لمعالجة الطلب الجديد، مما يسمح للمقبس وTCPListener بالاستمرار في استقبال اتصالات أخرى في نفس الوقت. ''',
      'lesson_second_image': 'assets/images/empty.jpg',
      'lesson_link': 'https://www.youtube.com/watch?v=9ANSu9Cg-Bo',
    });
    await db.insert('lessons', {
      'lesson_name': 'الدرس الخامس: معالجة البيانات الموزعة',
      'lesson_first_title':
          'بناء زبون TCP باستخدام مقابس تدفق البيانات  Sockets Stream',
      'lesson_first_content': '''
يتألف بناء تطبيق زبون يعتمد على مقابس تدفق البيانات (Sockets Stream) من أربع مراحل:

المرحلة الأولى: إنشاء زبون TCP  
في هذه المرحلة، يتم بناء كائن من الصنف TcpClient، الذي ينتمي إلى فضاء الأسماء System.Net.Sockets، للاتصال بالمخدم. يتم إنشاء الاتصال باستخدام الطريقة Connect من الصنف TcpClient، والتي تأخذ معاملين: عنوان المخدم (IPAddress) ورقم المنفذ (Port). 
يمكن أيضًا استدعاء الطريقة Connect باستخدام معامل واحد من نوع IPEndPoint، الذي يمثل عنوان IP ورقم المنفذ للمخدم. في حالة النجاح، تقوم الطريقة Connect بإجراء الاتصال.

المرحلة الثانية: توفير تدفق المعطيات  
يُستخدم الصنف TcpClient في هذه المرحلة لاستدعاء الطريقة GetStream للحصول على تدفق المعطيات الشبكي (Network Stream)، الذي يسمح بالقراءة من والكتابة إلى المخدم. 
يمكن استخدام الطريقتين Write وWriteByte لكتابة بايت واحد أو سلسلة من البايتات إلى تدفق المعطيات الشبكي. 
يمكن استخدام الطريقتين Read وReadByte للقراءة من المخدم.

المرحلة الثالثة: إرسال البيانات  
بعد الحصول على تدفق المعطيات الشبكي، يمكن إرسال البيانات إلى المخدم باستخدام الطريقة Write. يمكن إرسال بايت واحد أو سلسلة من البايتات باستخدام الطريقة Write.

المرحلة الرابعة: استقبال البيانات  
بعد إرسال البيانات، يمكن استقبال البيانات من المخدم باستخدام الطريقة Read. يمكن استقبال بايت واحد أو سلسلة من البايتات باستخدام الطريقة Read.

المرحلة الخامسة: معالجة الاتصال  
في هذه المرحلة، يتم استقبال وإرسال البيانات بين المخدم والعميل. تُستخدم فئة NetworkStream لقراءة وكتابة البيانات بين المخدم والعميل. تُستخدم الطرق Write وRead لكتابة وقراءة البيانات على التوالي، سواء كان بايت واحدًا أو سلسلة من البايتات.

المرحلة السادسة: إغلاق الاتصال  
بعد انتهاء الاتصال، يتم إغلاق الاتصال بين المخدم والعميل. تُستخدم الطريقة Close من فئة TcpClient لإغلاق المقبس الذي يستخدمه العميل. إذا كان المقبس متصلاً، يقوم العميل بإغلاق المقبس وتحرير المراجع من فئة TcpClient للاتصال. بعد ذلك، يمكن إعادة استخدام الطريقة Connect لإنشاء اتصال جديد.
''',
      'lesson_first_image': 'assets/images/empty.jpg',
      'lesson_second_title': 'التشبيك عن بعد',
      'lesson_second_content': '''
تعتبر تقنية "التشبيك عن بعد" في .NET واحدة من التقنيات المستخدمة في معالجة البيانات الموزعة. يتيح لك استخدام تقنيات "Remoting" في .NET الوصول إلى الموارد الموجودة على أجهزة أخرى عبر الشبكة.

يُشار إلى هذا النوع من الاتصال عادةً باسم "استدعاء الطرائق عن بعد" (Remote Method Invocation) في Java، أو "استدعاء الإجراءات عن بعد" (Remote Procedure Call) في لغات البرمجة الإجرائية. تتشابه هذه الخدمات مع خدمات الويب (Web Services) التي سيتم مناقشتها في الفصل القادم، ولكن هناك بعض الاختلافات.

في خدمات الويب، يقوم تطبيق العميل بالاتصال بخدمة الويب المستضافة على خادم الويب، ويمكن استخدام بروتوكولات مختلفة لتواصل العميل والخادم حتى لو كانت مكتوبة بلغات برمجة مختلفة. يمكن استخدام بروتوكول SOAP في التشبيك عن بعد في .NET.

عند استخدام التشبيك عن بعد في .NET، يقوم كل من العميل والخادم بإجراء الاتصال باستخدام Remote Method Invocation لاستدعاء الطرائق وإرسال البيانات. تشمل هذه العملية عناصر أساسية مثل:

- القنوات (Channels): تتيح للخادم والعميل الاتصال وتبادل المعلومات.
- إدارة البيانات (Marshaling): عملية تحويل البيانات إلى صيغة قابلة للإرسال عبر القنوات.
- التطبيق: تطبيق العميل أو الخادم الذي يعتمد على التشبيك عن بعد.

تستخدم القنوات إما بروتوكول HTTP أو بروتوكول TCP لإرسال الرسائل. يتميز HTTP بقدرته على النفاذ عبر جدران النار بشكل افتراضي، بينما يعتبر بروتوكول TCP مناسبًا للاتصال في الشبكات المحلية. يفضل في تطبيقات التشبيك عن بعد التي تقدمها .NET أن يتم فتح قنوات الاتصال باستخدام نفس البروتوكول، سواء كان HTTP أو TCP، وذلك لضمان تبادل البيانات بين العميل والخادم بكفاءة.

تعد الإدارة بالغرض ضرورية لتحويل الكائنات بين التطبيقات عبر الشبكات.
''',
      'lesson_second_image': 'assets/images/empty.jpg',
      'lesson_link': 'https://www.youtube.com/watch?v=9ANSu9Cg-Bo',
    });
    await db.insert('lessons', {
      'lesson_name': 'الدرس السادس: الادارة والتقانات',
      'lesson_first_title': 'الادارة',
      'lesson_first_content': '''
نقسم الإدارة إلى نوعين: الإدارة عن طريق القيمة (by value) والإدارة عن طريق المرجع (by reference).

الإدارة عن طريق القيمة:
تتطلب الإدارة عن طريق القيمة أن يكون الكائن قابلًا للتسلسل (Serializable)، مما يعني أنه يمكن تحويله إلى صيغة مناسبة لنقل البيانات عبر القنوات. يتم ذلك من خلال إجراءات التسلسل، حيث يقوم المصدر بإرسال الكائن إلى الوجهة، حيث يُعاد تشكيله (Deserialization) في الجهة المستقبلة.

لتمكين الكائنات من دعم الخصائص Serialized وDeserialized، يجب تمييز الصنف (class) بالصفة [Serializable] أو تنفيذ واجهة ISerializable.

الإدارة عن طريق المرجع:
تتطلب الإدارة عن طريق المرجع أن ينتمي الصنف إلى فئة Marshal By Ref Object. في هذه الحالة، يتم إنشاء كائن افتراضي يتم التواصل معه عن بعد.

هنا، يتم التعامل مع الكائن المرجعي البعيد (remote object)، والذي يتعامل فيه العميل مع وكيل شبكي (proxy) يمثل الكائن البعيد. عند استخدام الإدارة عن طريق المرجع، يتم التعامل مع الوكيل الشفاف (transparent proxy) والوكيل الحقيقي (real proxy).

الوكيل الشفاف يُظهر الكائن البعيد كما لو كان الكائن محليًا، بينما الوكيل الحقيقي يضمن تنفيذ الطلبات إلى الكائن البعيد. عندما يقوم العميل باستدعاء طريقة أو خاصية من خلال الوكيل الشفاف، يبدو الأمر كما لو أنه يستدعي الكائن مباشرة. لكن في الواقع، يقوم الوكيل الشفاف بإرسال الطلب إلى الوكيل الحقيقي، الذي يتولى تنفيذ الطلب على الخادم وإرجاع النتيجة إلى العميل.

بهذه الطريقة، تسمح الإدارة بالغرض بتوفير تفاعل سهل وفعال بين الكائنات الموجودة في أنظمة مختلفة عبر الشبكة.
''',
      'lesson_first_image': 'assets/images/empty.jpg',
      'lesson_second_title':
          'استخدام التقانات خدمات الويب لتبادل البيانات بين الأنظمة الموزعة ',
      'lesson_second_content': '''
تتيح التقنيات الحديثة في الأنظمة الموزعة تطبيقات لتبادل المعلومات بين الحواسيب عبر الشبكة. تعتبر خدمة الويب (Web Service) وسيلة رئيسية لتنسيق التفاعل بين الأنظمة الموزعة، حيث تستند إلى معايير وتطبيقات معينة، مثل طرق استدعاء الميثود (method invocation) وبروتوكولات الاتصال.

بروتوكول SOAP:
يُستخدم بروتوكول SOAP (Simple Object Access Protocol) كأحد المعايير الأساسية في خدمات الويب. يعتمد SOAP على XML لنقل البيانات، حيث يُسمح بتبادل الطلبات (requests) والاستجابات (responses) بين الأنظمة. يتم نقل هذه المعلومات غالباً عبر بروتوكول HTTP.

بفضل SOAP، يمكن للتطبيقات مشاركة البيانات في تنسيقات معيارية XML، مما يسهل عملية التكامل بين الأنظمة المختلفة.

دور Microsoft في خدمات الويب:
أصبحت شركات مثل Microsoft رائدة في تقديم برمجيات وخدمات الويب. مع تزايد الاعتماد على الإنترنت، أصبح دمج التطبيقات من خلال خدمات الويب ضرورة ملحة. يتميز تصميم برمجيات تكنولوجيا المعلومات الحديثة بظهور ممارسات تطوير برمجيات تعتمد على معايير هندسة الخدمات (Service-Oriented Architecture - SOA). يمكن لمطوري البرمجيات استخدام مجموعة متنوعة من المكتبات والأطر لتسهيل تطوير تطبيقات موجهة نحو الخدمات، مما يسمح بتوزيع المهام بين خدمات متعددة.

فوائد استخدام خدمات الويب:
- تسهيل التعاون: تساهم خدمات الويب في تسهيل التعاون بين التطبيقات المختلفة، مما يوفر وقت التطوير والجهد.
- تحسين المعلومات: تتيح قدرة التطبيقات على الوصول إلى خدمات متعددة معلومات دقيقة وتحديثات فورية، مثل حالة الطقس أو أسعار الصرف، مما يساعد في اتخاذ القرارات بشكل أسرع.
- زيادة الزوار: تسهم خدمات الويب في تحسين تجربة المستخدمين على مواقع الإنترنت، مما يؤدي إلى زيادة عدد الزوار والتفاعل.

مثال تطبيقي:
لنأخذ مثالاً عن شركة سفر وسياحة تستفيد من خدمات الويب لتقديم خدماتها. قد تشمل هذه الخدمات:
- خدمة ويب لمعرفة حالة الطقس للوجهة السياحية.
- خدمة ويب لمعرفة أسعار صرف العملات.
- خدمة ويب لمعرفة أسعار التذاكر.

يتضح من خلال هذا المثال كيف توفر خدمات الويب مزيدًا من المعلومات المفيدة للعملاء، مما يعزز من تجربة الخدمة ويساعد الشركات على تقديم عروض متميزة.
''',
      'lesson_second_image': 'assets/images/empty.jpg',
      'lesson_link': 'https://www.youtube.com/watch?v=9ANSu9Cg-Bo',
    });

    await db.insert('lessons', {
      'lesson_name': 'الدرس السابع: بروتوكولات الويب',
      'lesson_first_title': 'خدمات الويب Web Services',
      'lesson_first_content': '''
تمكن الحواسيب المتصلة بالشبكة من توصيل خدمة الويب عبر تطبيقات موجودة على حواسيب متعددة. تستخدم التطبيقات بروتوكولات لتسهيل التواصل عن بُعد مع تطبيقات أخرى. يقوم التطبيق المستضيف لخدمة الويب بمعالجة الطلبات وإرسال الإجابات إلى التطبيق المستدعي.

تعتمد هذه التقنية بشكل كبير على بعض المعايير والمكونات الأساسية لتقديم خدمات فعالة. تتواجد هذه الخدمات في العديد من التطبيقات التي تتيح التعامل مع البيانات، وتطلب قدرة كافية لمعالجة البيانات بطريقة سلسة، مما يمكن استخدامها بفعالية في مختلف المجالات.

تتكون خدمة الويب من فئات (Classes) ومجموعة من الطرق (Methods) المرتبطة بها. يتم نقل الطلبات والردود باستخدام بروتوكول SOAP، مما يعني أنه يمكن توصيل هذه الفئات ومعالجة رسائل SOAP.

يمكن استخدام خدمة الويب بأي لغة برمجة، بغض النظر عن اللغة التي كُتبت بها خدمة الويب. تتحكم خدمات الويب في الوصول إلى بياناتها من خلال آليات محددة، حيث يمكن فقط للكائنات المخولة (Authorized Objects) الوصول إلى هذه البيانات، مما يضمن أمان المعلومات وخصوصيتها.

تستخدم خدمات الويب بروتوكول SOAP، الذي يتعامل مع مجموعة من اللغات والبروتوكولات، مما يعزز التوافق البرمجي والعتادي. يتوافق SOAP مع معايير محددة تسهل تبادل البيانات بين الأنظمة المختلفة.

تتعاون العديد من الشركات مثل Amazon وGoogle وeBay في تقديم مجموعة من خدمات الويب، مما يسمح بشراكات قوية وتبادل المعلومات بكفاءة. تُستخدم أيضًا تقنيات مثل Remote Procedure Call (RPC) لتمكين التطبيقات من استدعاء وظائف عن بُعد عبر الشبكة.

تستند خدمات الويب على مبادئ محددة لضمان الاستجابة الفعالة عبر بروتوكولات مُعتمدة، وطرق (Methods) تضمن الأداء الجيد وسهولة التكامل بين الأنظمة المختلفة.
''',
      'lesson_first_image': 'assets/images/empty.jpg',
      'lesson_second_title':
          'بروتوكول SOAP (بروتوكول الوصول البسيط) تعريف بروتوكول SOAP',
      'lesson_second_content': '''
SOAP هو بروتوكول مستقل يُستخدم لتسهيل تبادل المعلومات بين التطبيقات عبر الشبكات. يعتمد البروتوكول على XML لتشكيل الرسائل، ويُستخدم بشكل رئيسي فوق البروتوكول HTTP لنقل البيانات.

1. الرسائل في SOAP
تتكون الرسائل في SOAP من طلبات (Requests) وإجابات (Responses) تعبر عن المعلومات المطلوبة والمعالجة اللازمة. كل رسالة SOAP تتضمن:
- Envelope: يغلف الرسالة ويحدد المكونات الأساسية.
- Header: يحتوي على المعلومات الإضافية المطلوبة، مثل خيارات التوجيه أو تفاصيل الأمان.
- Body: يحمل البيانات الأساسية للطلب أو الاستجابة.

2. اختيار البروتوكول
يُعتبر HTTP البروتوكول الرئيسي لنقل رسائل SOAP. يمكن استخدام HTTP وXML معًا لتبادل المعلومات بين التطبيقات والخدمات، مما يسهل التعامل مع الشبكات التي تحتوي على جدران نارية (Firewalls) حيث يمكن أن يمرّ بروتوكول HTTP بسهولة.

3. أنواع البيانات
يدعم SOAP العديد من أنواع البيانات، بما في ذلك:
- أنواع البيانات البدائية: مثل integer وdouble.
- أنواع البيانات المركبة: مثل Node XML وDate Time.
- المصفوفات (Arrays): يمكن أن تتضمنها الرسائل لتمثيل مجموعات من البيانات.

4. التفاعل مع خدمات الويب
عند تفاعل التطبيق مع خدمة ويب باستخدام SOAP:
- يُرسل التطبيق طلبًا (SOAP Request) يتضمن المعلومات اللازمة.
- تتم معالجة الطلب في خدمة الويب، ويرسل رد (SOAP Response) مرة أخرى إلى التطبيق.
- يتم استخدام proxy كحلقة وصل بين التطبيق وخدمة الويب، حيث يقوم بنقل الطلبات والاستجابات.

توليد البروكسي
يمكن استخدام أدوات مثل Visual Studio لتوليد proxy تلقائيًا، مما يسهل الاتصال بين التطبيقات وخدمات الويب. يقوم هذا البروكسي بتسهيل عملية الإرسال والاستقبال بين التطبيق والخدمة.

الخاتمة
بفضل هيكله المرن وقدرته على التعامل مع أنواع متعددة من البيانات، يُعتبر SOAP خيارًا مفضلًا في تطوير خدمات الويب. يتيح SOAP تكامل الأنظمة بسهولة ويضمن تبادل المعلومات بطريقة موثوقة.
''',
      'lesson_second_image': 'assets/images/empty.jpg',
      'lesson_link': 'https://www.youtube.com/watch?v=9ANSu9Cg-Bo',
    });

    await db
        .insert('tests', {'lesson_id': 1, 'test_name': 'إختبار الدرس الأول'});
    await db
        .insert('tests', {'lesson_id': 2, 'test_name': 'إختبار الدرس الثاني'});
    await db
        .insert('tests', {'lesson_id': 3, 'test_name': 'إختبار الدرس الثالث'});
    await db
        .insert('tests', {'lesson_id': 4, 'test_name': 'إختبار الدرس الرابع'});
    await db
        .insert('tests', {'lesson_id': 5, 'test_name': 'إختبار الدرس الخامس'});
    await db
        .insert('tests', {'lesson_id': 6, 'test_name': 'إختبار الدرس السادس'});
    await db
        .insert('tests', {'lesson_id': 7, 'test_name': 'إختبار الدرس السابع'});

    await db.insert('questions', {
      'test_id': 1,
      'question_text': 'ما هي ميزة تعددية النيسب في الحاسب:',
      'choice1': 'تنفيذ عملية واحدة في وقت واحد',
      'choice2': 'تنفيذ عدة عمليات بشكل متسلسل',
      'choice3': 'تنفيذ عدة عمليات بشكل متوازي',
      'choice4': 'توقف العمليات حتى انتهاء عملية واحدة',
      'correct_choice': 3,
      'reason':
          'لأن النيسب لديه قدرة العمل على التوازي، مما يسمح للحاسب بتنفيذ عمليات متعددة في نفس الوقت.',
    });

    await db.insert('questions', {
      'test_id': 1,
      'question_text':
          'ماذا يحدث عندما يطلب المستخدم تشغيل مقطع صوتي أو فيديو أثناء تحميله باستخدام تعددية النيسب؟',
      'choice1': 'يتم إيقاف عملية التحميل حتى يتم تشغيل المقطع',
      'choice2': 'يتم تحميل المقطع بالكامل قبل تشغيله',
      'choice3': 'يتم استخدام نيسب لتحميل المقطع وآخر لتشغيله في نفس الوقت',
      'choice4': 'يتم إغلاق البرنامج حتى يكتمل التحميل',
      'correct_choice': 3,
      'reason':
          'يتم استخدام نيسب لتحميل المقطع وآخر لتشغيله في نفس الوقت، مما يعزز كفاءة النظام ويقلل من زمن الانتظار.',
    });

    await db.insert('questions', {
      'test_id': 1,
      'question_text':
          'ما هو الحل لمشكلة الوصول إلى جزء من البيانات لم يتم تحميله بعد في تعددية النيسب؟',
      'choice1': 'إيقاف تشغيل النيسب حتى ينتهي النيسب الآخر من التحميل',
      'choice2': 'تجاهل الجزء غير المحمل',
      'choice3': 'استخدام مزامنة النيسب (Threads Synchronization)',
      'choice4': 'إغلاق البرنامج وإعادة تشغيله',
      'correct_choice': 3,
      'reason':
          'تستخدم مزامنة النيسب (Threads Synchronization) لحل مشكلة الوصول إلى جزء من البيانات لم يتم تحميله بعد، مما يضمن تناسق البيانات بين النيسب المختلفة.',
    });

    await db.insert('questions', {
      'test_id': 1,
      'question_text':
          'لماذا لم تكن ميزة تعددية النيسب سهلة الاستخدام في الماضي؟',
      'choice1':
          'كانت لغات البرمجة القديمة توفر أدوات متقدمة للتعامل مع النيسب',
      'choice2': 'كانت ميزة تعددية النيسب غير مدعومة من قبل معظم الأنظمة',
      'choice3':
          'كانت لغات البرمجة القديمة تفتقر إلى الأدوات اللازمة للتعامل مع النيسب',
      'choice4': 'لم يكن هناك حاجة لمزايا تعددية النيسب في البرمجة القديمة',
      'correct_choice': 3,
      'reason':
          'كانت لغات البرمجة القديمة تفتقر إلى الأدوات اللازمة للتعامل مع النيسب، مما جعل توظيف ميزة تعددية النيسب صعباً ومحصوراً على متخصصي برمجة النظم فقط.',
    });

    await db.insert('questions', {
      'test_id': 1,
      'question_text':
          'ما هي البيئة التي زودت جميع لغات البرمجة بأدوات التعامل مع النيسب مؤخراً؟',
      'choice1': 'Java',
      'choice2': 'Python',
      'choice3': '.NET',
      'choice4': 'Ada',
      'correct_choice': 3,
      'reason':
          'قامت بيئة العمل .NET بتزويد جميع لغات البرمجة الموجودة ضمنها بالأدوات التي تمكن المبرمجين من بناء النيسب والتعامل معها.',
    });

    await db.insert('questions', {
      'test_id': 1,
      'question_text': 'ما هي الحالة التي يبدأ منها نيسب جديد عند إنشائه؟',
      'choice1': 'حالة التشغيل (Running)',
      'choice2': 'حالة الإيقاف (Stopped)',
      'choice3': 'حالة عدم الانطلاق (Unstarted)',
      'choice4': 'حالة الإحباط (Aborted)',
      'correct_choice': 3,
      'reason':
          'يبدأ النيسب الجديد من حالة عدم الانطلاق (Unstarted) حتى يتم استدعاء الطريقة (Start).',
    });

    await db.insert('questions', {
      'test_id': 1,
      'question_text': 'ماذا يحدث لنيسب بعد استدعاء الطريقة (Start) في .NET؟',
      'choice1': 'يظل في حالة عدم الانطلاق',
      'choice2': 'يدخل في حالة التشغيل (Running)',
      'choice3': 'يدخل في حالة الإيقاف (Stopped)',
      'choice4': 'يدخل في حالة الإحباط (Aborted)',
      'correct_choice': 2,
      'reason':
          'عند استدعاء الطريقة (Start)، يدخل النيسب في حالة التشغيل (Running).',
    });

    await db.insert('questions', {
      'test_id': 1,
      'question_text': 'متى يدخل النيسب في حالة الإيقاف أو الإحباط؟',
      'choice1': 'عندما يتم استدعاء الطريقة (Start)',
      'choice2':
          'عندما ينهي النيسب المهمة الموكلة إليه بشكل طبيعي أو يتم استدعاء طريقة الإحباط',
      'choice3':
          'عندما يكون النيسب في حالة التشغيل ويطلب منه نيسب آخر الانتظار',
      'choice4': 'عندما يكون النيسب في حالة الانتظار',
      'correct_choice': 2,
      'reason':
          'يدخل النيسب في حالة الإيقاف أو الإحباط عندما ينهي المهمة الموكلة إليه أو عندما يتم استدعاء طريقة الإحباط.',
    });

    await db.insert('questions', {
      'test_id': 1,
      'question_text': 'ما هي الحالة التي يصبح فيها النيسب مجمدًا (Blocked)؟',
      'choice1': 'عندما يكون في حالة التشغيل (Running)',
      'choice2': 'عندما يكون في حالة الانتظار (Wait)',
      'choice3': 'عندما يكون في حالة الإيقاف (Stopped)',
      'choice4': 'عندما يكون في حالة عدم الانطلاق (Unstarted)',
      'correct_choice': 1,
      'reason':
          'يصبح النيسب مجمدًا عندما يكون عاجزًا عن استخدام أي معالج حتى وإن كان متاحًا، مثل طلب دخل/خرج أو مزامنة النياسب.',
    });

    await db.insert('questions', {
      'test_id': 1,
      'question_text': 'ما هو مفهوم "تجميد النيسب" في بيئة العمل .NET؟',
      'choice1': 'حالة حقيقية يمكن للنيسب الاستجابة لها',
      'choice2':
          'حالة غير حقيقية تُطلق على النيسب عندما لا يكون في حالة التشغيل',
      'choice3': 'حالة تنشأ فقط عند استدعاء الطريقة (Sleep)',
      'choice4': 'حالة تحدث عندما ينهي النيسب مهمته بشكل طبيعي',
      'correct_choice': 2,
      'reason':
          'تجميد النيسب هو مفهوم أو تعبير يُطلق على النيسب عندما لا يكون في حالة التشغيل وليس حالة حقيقية في بيئة العمل .NET.',
    });

    await db.insert('questions', {
      'test_id': 1,
      'question_text': 'كيف يدخل النيسب في حالة الانتظار (Wait)؟',
      'choice1': 'عندما يطلب النيسب إدخال/إخراج',
      'choice2': 'عندما يستدعي النيسب طريقة السبات (Sleep)',
      'choice3':
          'عندما يواجه تعليمة لا يمكن تنفيذها حالياً مثل استدعاء الطريقة (Wait) من الصنف Monitor',
      'choice4': 'عندما يتم استدعاء الطريقة (Join)',
      'correct_choice': 3,
      'reason':
          'يدخل النيسب في حالة الانتظار عندما يواجه تعليمة لا يمكن تنفيذها حالياً مثل استدعاء الطريقة (Wait) من الصنف Monitor.',
    });

    await db.insert('questions', {
      'test_id': 1,
      'question_text':
          'ما هي الطرق التي يمكن أن تعيد النيسب من حالة الانتظار (Wait)؟',
      'choice1': 'استدعاء الطريقة (Join) فقط',
      'choice2': 'استدعاء الطريقة (Pulse) أو (PulseAll)',
      'choice3': 'استدعاء الطريقة (Sleep)',
      'choice4': 'استدعاء الطريقة (Interrupt)',
      'correct_choice': 2,
      'reason':
          'يمكن للنيسب أن يعود من حالة الانتظار عندما يستدعي نيسب آخر في البرنامج الطريقة (Pulse) أو (PulseAll).',
    });

    await db.insert('questions', {
      'test_id': 1,
      'question_text': 'متى يدخل النيسب في حالة السبات (Sleep)؟',
      'choice1': 'عندما يستدعي الطريقة (Join)',
      'choice2': 'عندما يستدعي الطريقة (Sleep) ويمرر وقتاً محدداً',
      'choice3': 'عندما يواجه تعليمة لا يمكن تنفيذها حالياً',
      'choice4': 'عندما يكون في حالة انتظار',
      'correct_choice': 2,
      'reason':
          'يدخل النيسب في حالة السبات عندما يستدعي الطريقة (Sleep) ويمرر وقتاً محدداً، يعرف بالميلي ثانية.',
    });

    await db.insert('questions', {
      'test_id': 1,
      'question_text':
          'ما هي الطريقة التي يمكن استخدامها لإيقاف نيسب مؤقتاً وإعادته لاحقاً؟',
      'choice1': 'طريقة السبات (Sleep)',
      'choice2': 'طريقة الانتظار (Wait)',
      'choice3': 'طريقة الإيقاف المؤقت (Suspend)',
      'choice4': 'طريقة الاستئناف (Resume)',
      'correct_choice': 3,
      'reason':
          'يمكن استخدام طريقة الإيقاف المؤقت (Suspend) لإيقاف النيسب مؤقتاً، ويمكن إعادة النيسب إلى حالة التشغيل باستخدام طريقة الاستئناف (Resume).',
    });

    await db.insert('questions', {
      'test_id': 1,
      'question_text': 'متى يعود النيسب من حالة الإيقاف المؤقت؟',
      'choice1': 'عندما يستدعي النيسب طريقة الاستئناف (Resume)',
      'choice2': 'عندما ينتهي وقت السبات',
      'choice3': 'عندما يستدعي نيسب آخر الطريقة (Pulse)',
      'choice4': 'عندما ينهي النيسب مهمته بشكل طبيعي',
      'correct_choice': 1,
      'reason':
          'يعود النيسب من حالة الإيقاف المؤقت عندما يستدعي النيسب طريقة الاستئناف (Resume).',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text': 'ما هي درجة الأولوية الافتراضية للنياسب؟',
      'choice1': 'أفضلية دنيا (Lowest)',
      'choice2': 'أقل من الطبيعي (Below Normal)',
      'choice3': 'طبيعي (Normal)',
      'choice4': 'فوق الطبيعي (Above Normal)',
      'correct_choice': 3,
      'reason': 'درجة الأولوية الافتراضية للنياسب هي الطبيعي (Normal).',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text':
          'ما هي ميزة "اقتسام الوقت" (Time Slicing) في نظام التشغيل Windows؟',
      'choice1': 'تسمح للنياسب ذات الأولوية المتساوية بمشاركة المعالج',
      'choice2': 'تسمح للنياسب ذات الأولوية العليا باستخدام المعالج بشكل حصري',
      'choice3': 'تقوم بتحديد الأولوية الدنيا للنياسب تلقائيًا',
      'choice4': 'تسمح للنياسب الجديدة بتجاهل النياسب ذات الأولوية المنخفضة',
      'correct_choice': 1,
      'reason':
          'ميزة اقتسام الوقت تتيح للنياسب ذات الأولوية المتساوية فرصة مشاركة المعالج.',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text':
          'ماذا يحدث بعد انتهاء الكمة المخصصة لنيسب في نظام التشغيل Windows؟',
      'choice1': 'يواصل النيسب العمل حتى ينتهي',
      'choice2':
          'يُمنع النيسب من استخدام المعالج ويُعطى النيسب الآخر فرصة التنفيذ',
      'choice3': 'يُعاد تخصيص الكمة للنيسب ذاته',
      'choice4': 'يُعطى النيسب الآخر الأولوية في التنفيذ',
      'correct_choice': 2,
      'reason':
          'عند انتهاء الكمة المخصصة لنيسب، يُمنع من استخدام المعالج وتنتقل الفرصة لنيسب آخر إذا كان موجودًا.',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text': 'ما هي وظيفة مجدول النياسب (Thread Scheduler)؟',
      'choice1': 'ضمان أن النياسب ذات الأولوية الكبرى تعمل دائمًا',
      'choice2': 'تحديد الكمة المخصصة لكل نيسب',
      'choice3': 'تحديد أولوية النياسب الجديدة تلقائيًا',
      'choice4': 'تنظيم تنفيذ النياسب بناءً على حالة التشغيل',
      'correct_choice': 1,
      'reason':
          'وظيفة مجدول النياسب هي ضمان أن النياسب ذات الأولوية الكبرى تكون في حالة التشغيل دائمًا.',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text':
          'كيف يُعالج النيسب A و B في نظام ذو معالج وحيد وفقاً لطريقة "روبن الدائرية" (Round-Robin Fashion)؟',
      'choice1':
          'يأخذ النيسب A وقتاً ثم النيسب B، ثم يعود النيسب A وهكذا حتى ينتهي عملهما',
      'choice2': 'يعمل النيسب A حتى ينتهي ثم النيسب B حتى ينتهي',
      'choice3': 'يعمل النيسب B أولاً ثم النيسب A بعد انتهاء النيسب B',
      'choice4': 'يُخصص وقت متساوي لكل نيسب بشكل عشوائي',
      'correct_choice': 1,
      'reason':
          'في طريقة روبن الدائرية، يأخذ النيسب A وقتاً ثم النيسب B، ثم يعود النيسب A وهكذا حتى ينتهي عملهما.',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text':
          'ماذا يحدث للنياسب ذات الأولوية الدنيا عند ظهور نيسب جديد ذو أولوية أعلى؟',
      'choice1': 'يستمر النيسب ذو الأولوية الدنيا في العمل دون تغيير',
      'choice2': 'يمكن تأجيل تنفيذ النيسب ذو الأولوية الدنيا بشكل غير محدود',
      'choice3': 'يتم إنهاء عمل النيسب ذو الأولوية الدنيا فوراً',
      'choice4': 'يُعطى النيسب ذو الأولوية الدنيا أولوية أعلى بشكل مؤقت',
      'correct_choice': 2,
      'reason':
          'يمكن أن يؤدي ظهور نيسب ذو أولوية أعلى إلى تأجيل تنفيذ النياسب ذات الأولوية الدنيا بشكل غير محدود.',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text': 'كيف يمكن ضبط وتعيير أولوية النيسب في .NET؟',
      'choice1':
          'باستخدام خاصية (Priority) من مجموعة التعداد (Thread Priority)',
      'choice2': 'بواسطة تغيير حالة التشغيل للنيسب',
      'choice3': 'بإعادة تخصيص الكمة للنيسب',
      'choice4': 'من خلال تعديل زمن السبات للنيسب',
      'correct_choice': 1,
      'reason':
          'يمكن ضبط وتعيير أولوية النيسب باستخدام خاصية (Priority) التي تأخذ قيمها من مجموعة التعداد (Thread Priority).',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text':
          'ماذا يحدث إذا تم تعريف قيمة غير معرفة ضمن مجموعة التعداد (Thread Priority)؟',
      'choice1': 'سيتم تعيين قيمة افتراضية للنيسب',
      'choice2':
          'سيظهر استثناء أو خطأ في القيمة التي تم تمريرها (ArgumentException)',
      'choice3': 'سيتم تجاهل القيمة غير المعرفة',
      'choice4': 'سيتم تعيين أعلى أولوية للنيسب تلقائيًا',
      'correct_choice': 2,
      'reason':
          'إذا تم تعريف قيمة غير معرفة ضمن مجموعة التعداد، سيظهر استثناء أو خطأ في القيمة التي تم تمريرها (ArgumentException).',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text':
          'ماذا يحدث عندما تتشارك عدة نياسب في بيانات وتقوم بتعديلها بدون مزامنة؟',
      'choice1': 'تحديث البيانات يحدث بشكل متسلسل دون مشاكل',
      'choice2':
          'يمكن أن تحدث مشاكل تضارب حيث يتجاهل النيسب الأخير تعديلات النيسب الأول',
      'choice3': 'يتم دمج التعديلات من جميع النياسب بشكل تلقائي',
      'choice4': 'لا تتأثر البيانات بتعديلات النياسب',
      'correct_choice': 2,
      'reason':
          'عند عدم مزامنة النياسب، قد تحدث مشاكل تضارب حيث يتجاهل النيسب الأخير تعديلات النيسب الأول.',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text':
          'ما هي وظيفة المزامنة (Synchronization) بين النياسب عند التعامل مع بيانات معينة؟',
      'choice1': 'السماح لنيسب واحد فقط بمعالجة البيانات بشكل حصري',
      'choice2': 'السماح للنياسب بالتعامل مع البيانات بشكل متزامن',
      'choice3': 'توزيع البيانات بشكل عشوائي بين النياسب',
      'choice4': 'تسريع عملية تعديل البيانات',
      'correct_choice': 1,
      'reason':
          'المزامنة تسمح لنيسب واحد فقط بمعالجة البيانات بشكل حصري لضمان عدم حدوث مشاكل تضارب.',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text': 'كيف يقوم النيسب بطلب قفل على غرض معين؟',
      'choice1': 'باستخدام الطريقة (Enter) من الصف (Monitor)',
      'choice2': 'بإصدار استثناء (Exception)',
      'choice3': 'بإدخال البيانات في قائمة انتظار',
      'choice4': 'بالتوقيع على الغرض',
      'correct_choice': 1,
      'reason':
          'النيسب يقوم بطلب قفل على غرض معين باستخدام الطريقة (Enter) من الصف (Monitor).',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text':
          'ماذا يحدث عندما ينتهي النيسب من التعامل مع الغرض المقفل؟',
      'choice1': 'يُحرر الغرض من القفل باستخدام الطريقة (Exit)',
      'choice2': 'يظل الغرض مقفلاً حتى ينتهي النيسب الآخر',
      'choice3': 'يُعاد الغرض إلى حالة الانتظار',
      'choice4': 'يتم إيقاف النيسب بشكل دائم',
      'correct_choice': 1,
      'reason':
          'عند انتهاء النيسب من التعامل مع الغرض، يُحرر الغرض من القفل باستخدام الطريقة (Exit).',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text': 'ما هي حالة (Deadlock) وكيف تحدث؟',
      'choice1':
          'حالة عندما لا يمكن لنيسب تنفيذ مهمته بسبب انتظاره لنيسب آخر، والذي بدوره ينتظر تنفيذ النيسب الأول',
      'choice2': 'حالة عندما ينفذ النيسب جميع المهام بدون مشاكل',
      'choice3': 'حالة عندما ينتهي النيسب من عمله بشكل طبيعي',
      'choice4': 'حالة عندما يُنجز النيسب مهمته بشكل غير صحيح',
      'correct_choice': 1,
      'reason':
          'حالة (Deadlock) تحدث عندما لا يمكن لنيسب تنفيذ مهمته بسبب انتظاره لنيسب آخر، والذي بدوره ينتظر تنفيذ النيسب الأول.',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text': 'كيف يتم استخدام قفل الغرض في (C#)؟',
      'choice1': 'بواسطة تعليمة lock مع مرجع الغرض المراد قفله',
      'choice2': 'بإصدار أمر إيقاف النيسب',
      'choice3': 'بتعديل الخصائص الخاصة بالبيانات مباشرة',
      'choice4': 'بإضافة الغرض إلى قائمة انتظار خاصة',
      'correct_choice': 1,
      'reason':
          'في (C#)، يتم استخدام قفل الغرض باستخدام تعليمة lock مع مرجع الغرض المراد قفله.',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text': 'ماذا يحدث عندما يحرر النيسب الغرض من القفل في (C#)؟',
      'choice1': 'يُحرر الغرض ويعود إلى حالة الانتظار',
      'choice2': 'يمكن لنيسب آخر طلب القفل على نفس الغرض',
      'choice3': 'يتم إغلاق الغرض بشكل دائم',
      'choice4': 'يُعطى النيسب الأولوية في التنفيذ',
      'correct_choice': 2,
      'reason':
          'عندما يحرر النيسب الغرض من القفل، يمكن لنيسب آخر طلب القفل على نفس الغرض.',
    });

    await db.insert('questions', {
      'test_id': 2,
      'question_text': 'ما الفرق بين النيسب في حالة التجميد وحالة الانتظار؟',
      'choice1':
          'النيسب في حالة التجميد لا يستطيع استخدام المعالج، بينما النيسب في حالة الانتظار يعتمد على نيسب آخر لإعادته إلى حالة التشغيل',
      'choice2':
          'النيسب في حالة التجميد يمكنه العودة إلى حالة التشغيل مباشرة، بينما النيسب في حالة الانتظار يكون في وضع إيقاف دائم',
      'choice3':
          'النيسب في حالة التجميد ينفذ مهمته بشكل طبيعي، بينما النيسب في حالة الانتظار ينفذ مهام أخرى',
      'choice4': 'لا يوجد فرق بين حالتي التجميد والانتظار',
      'correct_choice': 1,
      'reason':
          'النيسب في حالة التجميد لا يستطيع استخدام المعالج، بينما النيسب في حالة الانتظار يعتمد على نيسب آخر لإعادته إلى حالة التشغيل.',
    });

    await db.insert('questions', {
      'test_id': 3,
      'question_text':
          'ما هي المكتبة البرمجية الأساسية في .NET لتطوير تطبيقات الويب وتطبيقات الإنترنت؟',
      'choice1': 'Microsoft Visual Studio',
      'choice2': 'Framework Class Library (FCL)',
      'choice3': 'ASP.NET Core',
      'choice4': 'Entity Framework',
      'correct_choice': 2,
      'reason':
          'المكتبة البرمجية الأساسية في .NET لتطوير تطبيقات الويب وتطبيقات الإنترنت هي Framework Class Library (FCL).',
    });

    await db.insert('questions', {
      'test_id': 3,
      'question_text':
          'ما هو الاتصال المرتبط (Connection-Oriented) في سياق الشبكات؟',
      'choice1': 'أسلوب يتيح برمجيين للتواصل ونقل البيانات بشكل غير موثوق',
      'choice2': 'أسلوب يتيح برمجيين للتواصل ونقل البيانات بشكل موثوق',
      'choice3': 'أسلوب يستخدم لتبادل الرسائل عبر بروتوكولات غير متصلة',
      'choice4': 'أسلوب يركز على تحسين الأداء عبر الشبكة بشكل عام',
      'correct_choice': 2,
      'reason':
          'الاتصال المرتبط (Connection-Oriented) يتيح لبرنامجين التواصل ونقل البيانات بشكل موثوق.',
    });

    await db.insert('questions', {
      'test_id': 3,
      'question_text':
          'ما الفرق الرئيسي بين الاتصال المرتبط (Connection-Oriented) والاتصال غير المرتبط (Connectionless)؟',
      'choice1': 'الاتصال غير المرتبط أكثر موثوقية من الاتصال المرتبط',
      'choice2': 'الاتصال المرتبط أكثر موثوقية من الاتصال غير المرتبط',
      'choice3': 'الاتصال غير المرتبط يعتمد على الاتصال عبر بروتوكولات خاصة',
      'choice4': 'الاتصال المرتبط لا يتطلب إقامة اتصال فعلي بين التطبيقات',
      'correct_choice': 2,
      'reason':
          'الاتصال المرتبط أكثر موثوقية من الاتصال غير المرتبط لأنه يضمن تسليم البيانات بشكل موثوق.',
    });

    await db.insert('questions', {
      'test_id': 3,
      'question_text': 'ما هي التقنية المستخدمة في البث المباشر عبر الإنترنت؟',
      'choice1': 'الاتصال المرتبط (Connection-Oriented)',
      'choice2': 'الاتصال غير المرتبط (Connectionless)',
      'choice3': 'الاتصال عبر البريد الإلكتروني',
      'choice4': 'الاتصال عبر الشبكة المحلية',
      'correct_choice': 2,
      'reason':
          'البث المباشر عبر الإنترنت يعتمد على الاتصال غير المرتبط (Connectionless) لنقل البيانات.',
    });

    await db.insert('questions', {
      'test_id': 3,
      'question_text':
          'ما هو مكون التحكم الجديد الذي يعتبر ضروريًا للتفاعل مع التطبيقات التي تستخدم الويب؟',
      'choice1': 'موجه الشبكة (Network Router)',
      'choice2': 'موجه الويب (Web Browser)',
      'choice3': 'خادم قواعد البيانات (Database Server)',
      'choice4': 'نظام التشغيل (Operating System)',
      'correct_choice': 2,
      'reason':
          'مكون التحكم الجديد الضروري للتفاعل مع التطبيقات التي تستخدم الويب هو موجه الويب (Web Browser).',
    });

    await db.insert('questions', {
      'test_id': 3,
      'question_text': 'ما هي تقنية الشبكات عن بُعد (Remoting) في .NET؟',
      'choice1': 'تتيح تنفيذ عمليات المعالجة الموزعة عبر الشبكة',
      'choice2': 'تعمل على تحسين أداء التطبيقات المحلية',
      'choice3': 'تدير قواعد البيانات في الشبكة',
      'choice4': 'تدير الشبكة المحلية فقط',
      'correct_choice': 1,
      'reason':
          'تقنية الشبكات عن بُعد (Remoting) في .NET تتيح تنفيذ عمليات المعالجة الموزعة عبر الشبكة.',
    });
    await db.insert('questions', {
      'test_id': 3,
      'question_text':
          'ما هي خاصية الاتصال المرتبط (Connection-Oriented Communication) التي تميزه؟',
      'choice1': 'إرسال الرسائل عبر مسارات متعددة',
      'choice2': 'تأسيس الاتصال والحفاظ عليه مفتوحًا حتى انتهاء التواصل',
      'choice3': 'تأخير وصول البيانات وفقدان بعض الرزم',
      'choice4': 'عدم ضمان توصيل الرزم بالترتيب الصحيح',
      'correct_choice': 2,
      'reason':
          'الخاصية المميزة للاتصال المرتبط هي تأسيس الاتصال والحفاظ عليه مفتوحًا حتى انتهاء التواصل.',
    });

    await db.insert('questions', {
      'test_id': 3,
      'question_text':
          'ما الفرق الرئيسي بين الاتصال المرتبط والاتصال عديم الارتباط؟',
      'choice1':
          'الاتصال المرتبط يضمن توصيل الرزم بدون فقدان أو تكرار، بينما الاتصال عديم الارتباط لا يضمن ذلك',
      'choice2':
          'الاتصال عديم الارتباط يضمن توصيل الرزم بالترتيب الصحيح، بينما الاتصال المرتبط لا يضمن ذلك',
      'choice3': 'الاتصال المرتبط أسرع من الاتصال عديم الارتباط',
      'choice4':
          'الاتصال عديم الارتباط يضمن الحفاظ على الاتصال مفتوحًا طوال فترة التواصل',
      'correct_choice': 1,
      'reason':
          'الاتصال المرتبط يضمن توصيل الرزم بدون فقدان أو تكرار، بينما الاتصال عديم الارتباط لا يضمن ذلك.',
    });

    await db.insert('questions', {
      'test_id': 3,
      'question_text':
          'ما هي التقنية المستخدمة في الاتصال المرتبط لضمان توصيل البيانات بالترتيب الصحيح؟',
      'choice1': 'المصافحة (Handshaking)',
      'choice2': 'إرسال الرزم عبر مسارات متعددة',
      'choice3': 'تأخير وصول البيانات',
      'choice4': 'عدم تأسيس اتصال مسبق',
      'correct_choice': 1,
      'reason':
          'التقنية المستخدمة في الاتصال المرتبط لضمان توصيل البيانات بالترتيب الصحيح هي المصافحة (Handshaking).',
    });

    await db.insert('questions', {
      'test_id': 3,
      'question_text':
          'ما هو نوع الاتصال الذي يعتبر غير موثوق لأنه لا يضمن توصيل البيانات بشكل دقيق؟',
      'choice1': 'الاتصال المرتبط (Connection-Oriented Communication)',
      'choice2': 'الاتصال عديم الارتباط (Connectionless Communication)',
      'choice3': 'الاتصال عبر البريد الإلكتروني',
      'choice4': 'الاتصال عبر الشبكة المحلية',
      'correct_choice': 2,
      'reason':
          'الاتصال عديم الارتباط يعتبر غير موثوق لأنه لا يضمن توصيل البيانات بشكل دقيق.',
    });

    await db.insert('questions', {
      'test_id': 3,
      'question_text': 'متى يكون الاتصال المرتبط الخيار المناسب؟',
      'choice1': 'عندما تكون السرعة والكفاءة هي الأكثر أهمية',
      'choice2': 'عندما تكون الموثوقية والتسلسل من الأولويات',
      'choice3': 'عندما لا تحتاج إلى ضمان توصيل البيانات',
      'choice4': 'عندما يكون تأخير وصول البيانات غير مهم',
      'correct_choice': 2,
      'reason':
          'الاتصال المرتبط يكون الخيار المناسب عندما تكون الموثوقية والتسلسل من الأولويات.',
    });

    await db.insert('questions', {
      'test_id': 4,
      'question_text':
          'ما هو البروتوكول الذي يضمن توصيل البيانات بشكل موثوق ويستخدم في العديد من البروتوكولات العليا مثل HTTP؟',
      'choice1': 'بروتوكول بيانات المستخدم (UDP)',
      'choice2': 'بروتوكول التحكم في النقل (TCP)',
      'choice3': 'بروتوكول الإنترنت (IP)',
      'choice4': 'بروتوكول التحكم في التدفق (FTP)',
      'correct_choice': 2,
      'reason':
          'بروتوكول التحكم في النقل (TCP) يضمن توصيل البيانات بشكل موثوق ويستخدم في العديد من البروتوكولات العليا مثل HTTP.',
    });

    await db.insert('questions', {
      'test_id': 4,
      'question_text': 'ما الفرق الرئيسي بين البروتوكول TCP والبروتوكول UDP؟',
      'choice1': 'TCP يضمن توصيل البيانات بشكل موثوق بينما UDP لا يضمن ذلك',
      'choice2': 'UDP يضمن ترتيب وصول البيانات بينما TCP لا يضمن ذلك',
      'choice3': 'TCP يستخدم أقل موارد الشبكة مقارنة بـ UDP',
      'choice4':
          'UDP يعيد إرسال البيانات في حال فقدانها بينما TCP لا يعيد الإرسال',
      'correct_choice': 1,
      'reason':
          'الفرق الرئيسي هو أن TCP يضمن توصيل البيانات بشكل موثوق بينما UDP لا يضمن ذلك.',
    });

    await db.insert('questions', {
      'test_id': 4,
      'question_text': 'ما هي الميزة التي يوفرها البروتوكول UDP مقارنة بـ TCP؟',
      'choice1': 'ضمان ترتيب وصول البيانات',
      'choice2': 'إعادة إرسال البيانات في حال فقدانها',
      'choice3': 'حمل أقل على الشبكة لعدم الحاجة إلى معلومات التحكم',
      'choice4': 'تجميع الرزم بالترتيب الصحيح',
      'correct_choice': 3,
      'reason':
          'البروتوكول UDP يوفر حملاً أقل على الشبكة لعدم الحاجة إلى معلومات التحكم مقارنة بـ TCP.',
    });

    await db.insert('questions', {
      'test_id': 4,
      'question_text':
          'في أي نوع من التطبيقات يكون استخدام البروتوكول UDP أكثر فعالية؟',
      'choice1': 'تطبيقات تتطلب تأكيد موثوق لوصول البيانات',
      'choice2':
          'تطبيقات تحتاج إلى سرعة عالية ويمكن أن تتسامح مع فقدان بعض البيانات',
      'choice3': 'تطبيقات تحتاج إلى تجميع الرزم بالترتيب الصحيح',
      'choice4': 'تطبيقات تحتاج إلى إعادة إرسال البيانات في حال فقدانها',
      'correct_choice': 2,
      'reason':
          'البروتوكول UDP يكون أكثر فعالية في التطبيقات التي تحتاج إلى سرعة عالية ويمكن أن تتسامح مع فقدان بعض البيانات، مثل نقل الصوت والفيديو.',
    });

    await db.insert('questions', {
      'test_id': 4,
      'question_text':
          'ما هو أحد الأسباب التي تجعل بعض التطبيقات تفضل استخدام البروتوكول UDP رغم عدم ضمانه لوصول البيانات؟',
      'choice1': 'لضمان توصيل البيانات بشكل موثوق',
      'choice2': 'لتقليل الحمل على الشبكة بسبب عدم الحاجة إلى معلومات التحكم',
      'choice3': 'لتنظيم وصول البيانات بالتسلسل الصحيح',
      'choice4': 'لإعادة إرسال البيانات في حالة فقدانها',
      'correct_choice': 2,
      'reason':
          'بعض التطبيقات تفضل استخدام البروتوكول UDP لتقليل الحمل على الشبكة بسبب عدم الحاجة إلى معلومات التحكم التي يحتاجها البروتوكول TCP.',
    });

    await db.insert('questions', {
      'test_id': 4,
      'question_text':
          'ما هي المرحلة الأولى في بناء مخدم TCP باستخدام مقابس تدفق البيانات؟',
      'choice1': 'معالجة الاتصالات',
      'choice2': 'تأسيس الاتصال بين المخدم والزبون',
      'choice3': 'إنشاء الكائن TCPListener',
      'choice4': 'إنهاء الاتصال',
      'correct_choice': 3,
      'reason':
          'المرحلة الأولى هي إنشاء الكائن TCPListener للاستماع لطلبات الاتصال.',
    });

    await db.insert('questions', {
      'test_id': 4,
      'question_text': 'كيف يتم بدء الاستماع لطلبات الاتصال في مخدم TCP؟',
      'choice1': 'عن طريق استدعاء الطريقة Accept من الكائن TCPListener',
      'choice2': 'عن طريق استدعاء الطريقة Start من الكائن TCPListener',
      'choice3': 'عن طريق استدعاء الطريقة Listen من الكائن Socket',
      'choice4': 'عن طريق استدعاء الطريقة Connect من الكائن Socket',
      'correct_choice': 2,
      'reason':
          'يجب استدعاء الطريقة Start من الكائن TCPListener ليبدأ في الاستماع لطلبات الاتصال.',
    });

    await db.insert('questions', {
      'test_id': 4,
      'question_text':
          'ما هي الدالة المستخدمة لقبول طلب الاتصال الجديد من عميل في مخدم TCP؟',
      'choice1': 'Accept',
      'choice2': 'AcceptSocket',
      'choice3': 'Connect',
      'choice4': 'Listen',
      'correct_choice': 2,
      'reason':
          'تُستخدم الطريقة AcceptSocket من الكائن TCPListener لقبول الطلب وإعادة كائن Socket يمثل الاتصال الجديد.',
    });

    await db.insert('questions', {
      'test_id': 4,
      'question_text':
          'ماذا يجب على المخدم فعله بعد الانتهاء من عملية استقبال وإرسال البيانات؟',
      'choice1': 'الانتظار لاستقبال اتصالات جديدة',
      'choice2': 'إغلاق الاتصال باستخدام الدالة Close',
      'choice3': 'إعادة تعيين الكائن TCPListener',
      'choice4': 'تغيير المنفذ إلى رقم آخر',
      'correct_choice': 2,
      'reason':
          'عند انتهاء الاتصال، يجب على المخدم استخدام الدالة Close من كائن Socket لإنهاء الاتصال بشكل صحيح.',
    });

    await db.insert('questions', {
      'test_id': 4,
      'question_text':
          'ما هو الحل لمشكلة حجب الطلبات الأخرى أثناء معالجة الطلبات الحالية في مخدم TCP؟',
      'choice1': 'استخدام البرمجة المتزامنة',
      'choice2': 'استخدام البرمجة متعددة الخيوط',
      'choice3': 'تقليل زمن معالجة الطلبات',
      'choice4': 'زيادة عدد المنافذ المتاحة',
      'correct_choice': 2,
      'reason':
          'لحل مشكلة حجب الطلبات الأخرى، يجب استخدام البرمجة متعددة الخيوط لتمكين المخدم من معالجة طلبات متعددة في وقت واحد.',
    });

    await db.insert('questions', {
      'test_id': 4,
      'question_text':
          'ما هي الطريقة المستخدمة للتعامل مع الطلبات الجديدة في البرمجة متعددة الخيوط ضمن مخدم TCP؟',
      'choice1': 'إنشاء خيط جديد لمعالجة الطلب',
      'choice2': 'إغلاق جميع الاتصالات الحالية',
      'choice3': 'تغيير إعدادات الكائن TCPListener',
      'choice4': 'تغيير رقم المنفذ',
      'correct_choice': 1,
      'reason':
          'عند استقبال اتصال جديد، يقوم المخدم بإنشاء خيط جديد لمعالجة الطلب الجديد، مما يسمح له بالاستمرار في استقبال اتصالات أخرى.',
    });

    await db.insert('questions', {
      'test_id': 4,
      'question_text':
          'ما هو الكائن الذي يتم استخدامه لإدارة الاتصال بين المخدم والعميل في بروتوكول TCP؟',
      'choice1': 'TCPListener',
      'choice2': 'Socket',
      'choice3': 'Datagram',
      'choice4': 'Stream',
      'correct_choice': 2,
      'reason':
          'يتم استخدام الكائن Socket لإدارة الاتصال بين المخدم والعميل في بروتوكول TCP.',
    });

    await db.insert('questions', {
      'test_id': 4,
      'question_text':
          'ماذا تفعل الدالتان Send وReceive في كائن Socket في مخدم TCP؟',
      'choice1': 'تبدأ الاتصال بين المخدم والعميل',
      'choice2': 'تُستخدم لإرسال واستقبال البيانات بين المخدم والعميل',
      'choice3': 'تنشئ اتصالاً جديداً بين المخدم والعميل',
      'choice4': 'تُغلق الاتصال بين المخدم والعميل',
      'correct_choice': 2,
      'reason':
          'تُستخدم الدالتان Send وReceive لإرسال واستقبال البيانات بين المخدم والعميل عبر كائن Socket.',
    });

    await db.insert('questions', {
      'test_id': 4,
      'question_text':
          'ما هي الميزة الأساسية التي يوفرها TCP مقارنة بـ UDP في سياق إنشاء خادم TCP؟',
      'choice1': 'تأكيد موثوقية توصيل البيانات',
      'choice2': 'سرعة إرسال البيانات',
      'choice3': 'عدم الحاجة إلى استخدام مقبس (Socket)',
      'choice4': 'إمكانية إرسال بيانات عبر عدة مسارات',
      'correct_choice': 1,
      'reason':
          'البروتوكول TCP يوفر تأكيد موثوقية توصيل البيانات، وهو ميزة أساسية مقارنة بـ UDP.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text':
          'ما هي المرحلة الأولى في بناء تطبيق زبون يعتمد على مقابس تدفق البيانات؟',
      'choice1': 'توفير تدفق المعطيات',
      'choice2': 'إرسال البيانات',
      'choice3': 'إنشاء زبون TCP',
      'choice4': 'إغلاق الاتصال',
      'correct_choice': 3,
      'reason':
          'المرحلة الأولى هي إنشاء زبون TCP باستخدام الصنف TcpClient للاتصال بالمخدم.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text': 'كيف يتم توفير تدفق المعطيات الشبكي بعد إنشاء زبون TCP؟',
      'choice1': 'باستخدام الطريقة Connect',
      'choice2': 'باستخدام الطريقة GetStream',
      'choice3': 'باستخدام الطريقة Close',
      'choice4': 'باستخدام الطريقة Accept',
      'correct_choice': 2,
      'reason':
          'يتم توفير تدفق المعطيات الشبكي باستخدام الطريقة GetStream من الصنف TcpClient.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text':
          'ما هي الطريقة المستخدمة لإرسال البيانات إلى المخدم باستخدام تدفق المعطيات الشبكي؟',
      'choice1': 'Read',
      'choice2': 'Write',
      'choice3': 'Connect',
      'choice4': 'Accept',
      'correct_choice': 2,
      'reason':
          'تُستخدم الطريقة Write لإرسال البيانات إلى المخدم عبر تدفق المعطيات الشبكي.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text': 'ما هي الطريقة المستخدمة لاستقبال البيانات من المخدم؟',
      'choice1': 'Read',
      'choice2': 'Write',
      'choice3': 'Close',
      'choice4': 'GetStream',
      'correct_choice': 1,
      'reason':
          'تُستخدم الطريقة Read لاستقبال البيانات من المخدم عبر تدفق المعطيات الشبكي.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text': 'ماذا يجب أن تفعل بعد انتهاء الاتصال في تطبيق الزبون؟',
      'choice1': 'إعادة استخدام الطريقة Connect لإنشاء اتصال جديد',
      'choice2': 'إغلاق الاتصال باستخدام الطريقة Close',
      'choice3': 'إعادة تعيين عنوان IP ورقم المنفذ',
      'choice4': 'تغيير نوع الصنف TcpClient',
      'correct_choice': 2,
      'reason':
          'بعد انتهاء الاتصال، يجب إغلاق الاتصال باستخدام الطريقة Close من فئة TcpClient.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text':
          'ما هو الكائن الذي يُستخدم لقراءة وكتابة البيانات بين المخدم والعميل؟',
      'choice1': 'TcpClient',
      'choice2': 'NetworkStream',
      'choice3': 'Socket',
      'choice4': 'IPEndPoint',
      'correct_choice': 2,
      'reason':
          'تُستخدم فئة NetworkStream لقراءة وكتابة البيانات بين المخدم والعميل.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text':
          'ما هي الطريقة التي تُستخدم لإنشاء اتصال بالمخدم باستخدام عنوان IP ورقم المنفذ؟',
      'choice1': 'GetStream',
      'choice2': 'Write',
      'choice3': 'Connect',
      'choice4': 'Accept',
      'correct_choice': 3,
      'reason':
          'تُستخدم الطريقة Connect من الصنف TcpClient لإنشاء اتصال بالمخدم باستخدام عنوان IP ورقم المنفذ.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text':
          'ما هي الطريقة المستخدمة لإغلاق المقبس بعد انتهاء الاتصال؟',
      'choice1': 'Write',
      'choice2': 'Read',
      'choice3': 'Connect',
      'choice4': 'Close',
      'correct_choice': 4,
      'reason':
          'تُستخدم الطريقة Close من فئة TcpClient لإغلاق المقبس بعد انتهاء الاتصال.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text':
          'ما هو اسم التقنية المستخدمة في .NET للوصول إلى الموارد على أجهزة أخرى عبر الشبكة؟',
      'choice1': 'Sockets Stream',
      'choice2': 'التشبيك عن بعد (Remoting)',
      'choice3': 'خدمات الويب (Web Services)',
      'choice4': 'Multithreading',
      'correct_choice': 2,
      'reason':
          'التشبيك عن بعد (Remoting) في .NET يُستخدم للوصول إلى الموارد على أجهزة أخرى عبر الشبكة.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text':
          'ما هو البروتوكول الذي يُفضل استخدامه في الاتصال عبر الشبكات المحلية باستخدام تقنية Remoting؟',
      'choice1': 'HTTP',
      'choice2': 'UDP',
      'choice3': 'FTP',
      'choice4': 'TCP',
      'correct_choice': 4,
      'reason':
          'بروتوكول TCP يُعتبر مناسبًا للاتصال في الشبكات المحلية عند استخدام تقنية Remoting.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text':
          'ما هي العملية التي تتضمن تحويل البيانات إلى صيغة قابلة للإرسال عبر القنوات في التشبيك عن بعد؟',
      'choice1': 'التخزين المؤقت (Caching)',
      'choice2': 'إدارة البيانات (Marshaling)',
      'choice3': 'تحليل البيانات (Parsing)',
      'choice4': 'الضغط (Compression)',
      'correct_choice': 2,
      'reason':
          'إدارة البيانات (Marshaling) هي عملية تحويل البيانات إلى صيغة قابلة للإرسال عبر القنوات.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text':
          'ما هو الفرق الأساسي بين التشبيك عن بعد (Remoting) وخدمات الويب (Web Services)؟',
      'choice1':
          'خدمات الويب تعتمد على HTTP فقط، بينما يمكن للتشبيك عن بعد استخدام HTTP أو TCP',
      'choice2': 'التشبيك عن بعد يعتمد على بروتوكولات SOAP فقط',
      'choice3': 'التشبيك عن بعد يُستخدم فقط في الشبكات المحلية',
      'choice4': 'خدمات الويب تعمل فقط في بيئات غير موثوقة',
      'correct_choice': 1,
      'reason':
          'التشبيك عن بعد في .NET يمكنه استخدام بروتوكولات HTTP أو TCP، بينما تعتمد خدمات الويب عادةً على HTTP.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text':
          'أي من العناصر التالية يعتبر جزءًا أساسيًا من عملية التشبيك عن بعد في .NET؟',
      'choice1': 'التخزين المؤقت',
      'choice2': 'القنوات (Channels)',
      'choice3': 'الجدران النارية',
      'choice4': 'التشفير',
      'correct_choice': 2,
      'reason':
          'القنوات (Channels) هي جزء أساسي في عملية التشبيك عن بعد، حيث تتيح الاتصال وتبادل المعلومات بين الخادم والعميل.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text':
          'ما هو الهدف من استخدام Remote Method Invocation في التشبيك عن بعد؟',
      'choice1': 'إرسال البيانات بشكل غير متزامن',
      'choice2': 'استدعاء الطرائق على خادم بعيد وإرسال البيانات',
      'choice3': 'تخزين البيانات بشكل محلي',
      'choice4': 'تحليل البيانات واسترجاعها',
      'correct_choice': 2,
      'reason':
          'Remote Method Invocation يُستخدم لاستدعاء الطرائق عن بعد وإرسال البيانات بين العميل والخادم.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text':
          'أي من البروتوكولات التالية يُعتبر قادرًا على النفاذ عبر جدران النار بشكل افتراضي؟',
      'choice1': 'UDP',
      'choice2': 'TCP',
      'choice3': 'HTTP',
      'choice4': 'FTP',
      'correct_choice': 3,
      'reason':
          'بروتوكول HTTP يُعتبر قادرًا على النفاذ عبر جدران النار بشكل افتراضي.',
    });

    await db.insert('questions', {
      'test_id': 5,
      'question_text':
          'لماذا يُفضل استخدام نفس البروتوكول في قنوات الاتصال لتطبيقات التشبيك عن بعد؟',
      'choice1': 'لتقليل حجم البيانات المرسلة',
      'choice2': 'لضمان التوافق وتبادل البيانات بكفاءة بين العميل والخادم',
      'choice3': 'لتقليل زمن الاستجابة',
      'choice4': 'لتقليل تكاليف التشغيل',
      'correct_choice': 2,
      'reason':
          'استخدام نفس البروتوكول في قنوات الاتصال يضمن التوافق وتبادل البيانات بكفاءة بين العميل والخادم.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text':
          'ما هو الشرط الأساسي لكي يكون الكائن قابلًا للإدارة عن طريق القيمة (by value)؟',
      'choice1': 'يجب أن يكون الكائن مشتقًا من فئة Marshal By Ref Object',
      'choice2': 'يجب أن يكون الكائن قابلًا للتسلسل (Serializable)',
      'choice3': 'يجب أن يكون الكائن وكيلًا شفافًا',
      'choice4': 'يجب أن يكون الكائن ذو حجم صغير',
      'correct_choice': 2,
      'reason':
          'لكي يكون الكائن قابلًا للإدارة عن طريق القيمة، يجب أن يكون قابلاً للتسلسل (Serializable) حتى يمكن تحويله إلى صيغة مناسبة للنقل.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text': 'ماذا تعني الصفة [Serializable] في .NET؟',
      'choice1': 'أن الكائن يمكن استدعاؤه عن بعد',
      'choice2': 'أن الكائن يمكن تحويله إلى نص',
      'choice3': 'أن الكائن يمكن تحويله إلى صيغة يمكن نقلها عبر الشبكة',
      'choice4': 'أن الكائن يمكن استخدامه فقط في تطبيقات محلية',
      'correct_choice': 3,
      'reason':
          'الصفة [Serializable] تعني أن الكائن يمكن تحويله إلى صيغة يمكن نقلها عبر الشبكة وإعادة تشكيله في الجهة المستقبلة.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text':
          'ما هي الوظيفة الرئيسية للوكيل الشفاف (transparent proxy) في الإدارة عن طريق المرجع؟',
      'choice1': 'إرسال البيانات مباشرة إلى الكائن البعيد',
      'choice2': 'تمثيل الكائن البعيد وكأنه كائن محلي',
      'choice3': 'تحليل البيانات الواردة من الشبكة',
      'choice4': 'التعامل مع جدران النار',
      'correct_choice': 2,
      'reason':
          'الوكيل الشفاف يُظهر الكائن البعيد كما لو كان كائنًا محليًا للعميل.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text':
          'أي من الخيارات التالية يُستخدم لتنفيذ الطلبات إلى الكائن البعيد في الإدارة عن طريق المرجع؟',
      'choice1': 'الوكيل الشفاف فقط',
      'choice2': 'الوكيل الحقيقي (real proxy)',
      'choice3': 'العميل مباشرة',
      'choice4': 'الوسيط (Mediator)',
      'correct_choice': 2,
      'reason':
          'الوكيل الحقيقي (real proxy) يتولى تنفيذ الطلبات على الكائن البعيد وإرجاع النتيجة إلى العميل.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text':
          'كيف يتم إعادة تشكيل الكائن في الجهة المستقبلة عند استخدام الإدارة عن طريق القيمة؟',
      'choice1': 'باستخدام الوكيل الشفاف',
      'choice2': 'من خلال عملية Deserialization',
      'choice3': 'عبر الوكيل الحقيقي',
      'choice4': 'باستخدام تقنية التخزين المؤقت',
      'correct_choice': 2,
      'reason':
          'عملية إعادة تشكيل الكائن تُسمى Deserialization، حيث يتم تحويل البيانات المستلمة إلى كائن مرة أخرى.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text':
          'ما هي الفائدة الأساسية من استخدام الإدارة بالغرض (Marshaling) في تطبيقات الشبكات؟',
      'choice1': 'تقليل حجم البيانات المرسلة عبر الشبكة',
      'choice2': 'توفير تفاعل سهل وفعال بين الكائنات الموجودة في أنظمة مختلفة',
      'choice3': 'تحسين أمان الاتصال',
      'choice4': 'زيادة سرعة نقل البيانات',
      'correct_choice': 2,
      'reason':
          'الإدارة بالغرض توفر تفاعلًا سهلًا وفعالًا بين الكائنات الموجودة في أنظمة مختلفة عبر الشبكة، مما يسهل عملية الاتصال بين العميل والخادم.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text':
          'أي من الطرق التالية تستخدم لتحويل الكائنات إلى صيغة قابلة للنقل عبر القنوات؟',
      'choice1': 'التسلسل (Serialization)',
      'choice2': 'التشفير (Encryption)',
      'choice3': 'الضغط (Compression)',
      'choice4': 'التخزين المؤقت (Caching)',
      'correct_choice': 1,
      'reason':
          'التسلسل (Serialization) يُستخدم لتحويل الكائنات إلى صيغة قابلة للنقل عبر القنوات.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text':
          'ما هو الدور الذي يلعبه الوكيل الحقيقي (Real Proxy) في الاتصال البعيد؟',
      'choice1': 'يحاكي الكائن المحلي',
      'choice2': 'يرسل الطلبات إلى الكائن البعيد وينفذها',
      'choice3': 'يقوم بضغط البيانات',
      'choice4': 'يُظهر الكائن البعيد كما لو كان كائنًا محليًا',
      'correct_choice': 2,
      'reason':
          'الوكيل الحقيقي هو الذي يرسل الطلبات إلى الكائن البعيد وينفذها، ويتولى إرجاع النتائج إلى العميل.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text':
          'ما هو البروتوكول المستخدم في خدمات الويب لتبادل البيانات باستخدام تنسيقات معيارية XML؟',
      'choice1': 'TCP',
      'choice2': 'UDP',
      'choice3': 'SOAP',
      'choice4': 'FTP',
      'correct_choice': 3,
      'reason':
          'يُستخدم بروتوكول SOAP (Simple Object Access Protocol) كمعيار أساسي في خدمات الويب لتبادل البيانات باستخدام تنسيقات معيارية XML.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text': 'كيف يساعد بروتوكول SOAP في تكامل الأنظمة المختلفة؟',
      'choice1': 'من خلال استخدام تقنيات التشفير القوية',
      'choice2': 'عن طريق نقل البيانات عبر UDP',
      'choice3': 'عن طريق تبادل البيانات في تنسيقات معيارية XML',
      'choice4': 'باستخدام التخزين المؤقت',
      'correct_choice': 3,
      'reason':
          'بروتوكول SOAP يعتمد على تبادل البيانات في تنسيقات معيارية XML، مما يسهل التكامل بين الأنظمة المختلفة.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text': 'ما هي فوائد استخدام خدمات الويب في التطبيقات الموزعة؟',
      'choice1': 'زيادة تكاليف التطوير',
      'choice2': 'تسهيل التعاون بين التطبيقات المختلفة',
      'choice3': 'تقييد الوصول إلى البيانات',
      'choice4': 'تقليل الأمان',
      'correct_choice': 2,
      'reason':
          'تُساهم خدمات الويب في تسهيل التعاون بين التطبيقات المختلفة، مما يوفر وقت التطوير والجهد ويعزز من تكامل الأنظمة.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text': 'ما هو دور Microsoft في تطوير خدمات الويب؟',
      'choice1': 'تقديم بروتوكولات مخصصة للاتصال بين الحواسيب',
      'choice2': 'تقديم برمجيات وأطر تدعم تكامل الأنظمة عبر خدمات الويب',
      'choice3': 'توفير أدوات لتحليل البيانات فقط',
      'choice4': 'تقديم خدمات بريد إلكتروني فقط',
      'correct_choice': 2,
      'reason':
          'تقدم Microsoft برمجيات وأطر تسهل تطوير وتكامل الأنظمة عبر خدمات الويب، مما يدعم بناء تطبيقات موجهة نحو الخدمات (SOA).',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text': 'ما هي تقنية SOA التي تستخدمها خدمات الويب؟',
      'choice1': 'تكنولوجيا شبكات محلية (LAN)',
      'choice2': 'هندسة الخدمات الموجهة (Service-Oriented Architecture)',
      'choice3': 'تكنولوجيا تخزين السحابة (Cloud Storage)',
      'choice4': 'الذكاء الاصطناعي (AI)',
      'correct_choice': 2,
      'reason':
          'خدمات الويب تعتمد على معايير هندسة الخدمات الموجهة (SOA) لتوزيع المهام بين خدمات متعددة وتسهيل التكامل بين التطبيقات.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text':
          'في مثال شركة السفر والسياحة، ما هي إحدى فوائد استخدام خدمات الويب؟',
      'choice1': 'توفير حماية من الفيروسات',
      'choice2': 'تقليل استهلاك الطاقة في الحواسيب',
      'choice3': 'تقديم معلومات محدثة عن الطقس وأسعار العملات للعملاء',
      'choice4': 'تقييد الوصول إلى مواقع السفر',
      'correct_choice': 3,
      'reason':
          'تستخدم شركة السفر والسياحة خدمات الويب لتقديم معلومات محدثة عن الطقس وأسعار العملات، مما يعزز تجربة العملاء.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text':
          'ما الذي يميز بروتوكول HTTP عند استخدامه في قنوات الاتصال لخدمات الويب؟',
      'choice1': 'عدم القدرة على النفاذ عبر جدران النار',
      'choice2': 'سرعته الفائقة في نقل الملفات الكبيرة',
      'choice3': 'القدرة على النفاذ عبر جدران النار بشكل افتراضي',
      'choice4': 'تقييد استخدامه داخل الشبكات المحلية فقط',
      'correct_choice': 3,
      'reason':
          'بروتوكول HTTP يتميز بقدرته على النفاذ عبر جدران النار بشكل افتراضي، مما يجعله مناسبًا لاستخدامات خدمات الويب.',
    });

    await db.insert('questions', {
      'test_id': 6,
      'question_text':
          'كيف تُسهم خدمات الويب في تحسين تجربة المستخدمين على مواقع الإنترنت؟',
      'choice1': 'عن طريق تقليل عدد الزوار',
      'choice2': 'من خلال تقديم تحديثات فورية ومعلومات دقيقة',
      'choice3': 'بإبطاء سرعة تحميل الصفحات',
      'choice4': 'بزيادة تكاليف البنية التحتية للموقع',
      'correct_choice': 2,
      'reason':
          'خدمات الويب تُسهم في تقديم تحديثات فورية ومعلومات دقيقة، مما يُحسن من تجربة المستخدمين ويزيد من تفاعلهم مع الموقع.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text':
          'ما هو البروتوكول الأساسي المستخدم لنقل الطلبات والردود في خدمات الويب؟',
      'choice1': 'FTP',
      'choice2': 'HTTP',
      'choice3': 'SOAP',
      'choice4': 'SMTP',
      'correct_choice': 3,
      'reason':
          'بروتوكول SOAP يُستخدم كمعيار أساسي لنقل الطلبات والردود في خدمات الويب، مما يعزز من توافق الأنظمة المختلفة.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text': 'كيف يمكن لخدمات الويب ضمان أمان البيانات وخصوصيتها؟',
      'choice1': 'من خلال الاعتماد على تشفير البيانات',
      'choice2': 'باستخدام آليات تحدد الكائنات المخولة للوصول إلى البيانات',
      'choice3': 'بتحديد نطاقات الشبكة الخاصة',
      'choice4': 'بتخزين البيانات على الحواسيب المحلية فقط',
      'correct_choice': 2,
      'reason':
          'تضمن خدمات الويب أمان المعلومات وخصوصيتها من خلال استخدام آليات تحدد الكائنات المخولة بالوصول إلى البيانات.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text': 'ما هي أهمية استخدام SOAP في خدمات الويب؟',
      'choice1': 'لإرسال رسائل بريد إلكتروني',
      'choice2': 'لضمان التوافق البرمجي والعتادي بين الأنظمة المختلفة',
      'choice3': 'لتوفير اتصال مباشر بين العملاء',
      'choice4': 'لتحليل البيانات البيانية',
      'correct_choice': 2,
      'reason':
          'يساعد استخدام SOAP في ضمان التوافق البرمجي والعتادي بين الأنظمة المختلفة، مما يسهل تبادل البيانات.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text':
          'ما الدور الذي تلعبه شركات مثل Amazon وGoogle في مجال خدمات الويب؟',
      'choice1': 'تقديم حلول تخزين البيانات فقط',
      'choice2': 'تطوير بروتوكولات جديدة للتواصل عن بعد',
      'choice3':
          'تقديم مجموعة من خدمات الويب التي تدعم تبادل المعلومات والشراكات بين الأنظمة',
      'choice4': 'تحليل النصوص والبيانات اللغوية',
      'correct_choice': 3,
      'reason':
          'شركات مثل Amazon وGoogle تقدم خدمات ويب تتيح تبادل المعلومات بفعالية بين الأنظمة المختلفة وتدعم الشراكات القوية.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text':
          'ما الفائدة من استخدام Remote Procedure Call (RPC) في خدمات الويب؟',
      'choice1': 'لتحديد المستخدمين المصرح لهم',
      'choice2': 'لتمكين التطبيقات من استدعاء وظائف عن بُعد عبر الشبكة',
      'choice3': 'لإجراء اتصالات مشفرة فقط',
      'choice4': 'لتحسين أداء قاعدة البيانات',
      'correct_choice': 2,
      'reason':
          'تقنية RPC تستخدم في خدمات الويب لتمكين التطبيقات من استدعاء وظائف عن بُعد عبر الشبكة، مما يسهل التكامل والتفاعل بين الأنظمة.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text':
          'ما هي الفئات (Classes) والطرق (Methods) في خدمات الويب المستخدمة لتسهيل التعامل مع البيانات؟',
      'choice1': 'تستخدم فقط في لغات البرمجة المحددة مثل Java',
      'choice2':
          'يمكن استخدامها في أي لغة برمجة بغض النظر عن اللغة المستخدمة لخدمة الويب',
      'choice3': 'تستخدم فقط لتطوير تطبيقات المحمول',
      'choice4': 'تستخدم لتخزين البيانات على الحواسيب',
      'correct_choice': 2,
      'reason':
          'الفئات والطرق في خدمات الويب يمكن استخدامها في أي لغة برمجة، مما يتيح للتطبيقات المختلفة التعامل مع البيانات بغض النظر عن اللغة الأصلية المستخدمة.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text':
          'كيف تساهم خدمات الويب في تسهيل التكامل بين الأنظمة المختلفة؟',
      'choice1': 'من خلال استخدام بروتوكولات خاصة فقط',
      'choice2': 'بفضل التوافق مع معايير محددة تتيح تبادل البيانات بكفاءة',
      'choice3': 'بتقليل عدد الطلبات المرسلة',
      'choice4': 'بتخزين البيانات في قواعد بيانات محلية فقط',
      'correct_choice': 2,
      'reason':
          'خدمات الويب تسهل التكامل بين الأنظمة المختلفة بفضل التوافق مع معايير مثل SOAP، مما يسمح بتبادل البيانات بكفاءة بين الأنظمة.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text':
          'ما هي المكونات الأساسية التي تعتمد عليها خدمات الويب لتقديم خدمات فعالة؟',
      'choice1': 'التخزين السحابي والأمان',
      'choice2': 'بروتوكولات الاتصال ومعالجة البيانات',
      'choice3': 'شبكات التواصل الاجتماعي',
      'choice4': 'تحليل البيانات والذكاء الاصطناعي',
      'correct_choice': 2,
      'reason':
          'تعتمد خدمات الويب على بروتوكولات الاتصال ومعالجة البيانات لتقديم خدمات فعالة تتيح التعامل بين الحواسيب المتصلة بالشبكة.',
    });
    await db.insert('questions', {
      'test_id': 7,
      'question_text': 'ما هي المكونات الأساسية التي تتكون منها رسالة SOAP؟',
      'choice1': 'Envelope و Header فقط',
      'choice2': 'Body و Footer',
      'choice3': 'Envelope و Header و Body',
      'choice4': 'Header و Footer فقط',
      'correct_choice': 3,
      'reason':
          'تتكون رسالة SOAP من ثلاثة مكونات أساسية: Envelope الذي يغلف الرسالة، وHeader الذي يحتوي على معلومات إضافية، وBody الذي يحمل البيانات الرئيسية.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text': 'أي بروتوكول يُستخدم بشكل رئيسي لنقل رسائل SOAP؟',
      'choice1': 'FTP',
      'choice2': 'HTTP',
      'choice3': 'SMTP',
      'choice4': 'HTTPS',
      'correct_choice': 2,
      'reason':
          'يُستخدم بروتوكول HTTP بشكل رئيسي لنقل رسائل SOAP، وذلك بسبب قدرته على المرور بسهولة عبر جدران النار.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text': 'ما الغرض من استخدام عنصر Header في رسالة SOAP؟',
      'choice1': 'لحمل البيانات الأساسية للطلب أو الاستجابة',
      'choice2': 'لتحديد نوع البيانات في الرسالة',
      'choice3': 'لتوفير معلومات إضافية مثل خيارات التوجيه أو تفاصيل الأمان',
      'choice4': 'لتشفير الرسالة',
      'correct_choice': 3,
      'reason':
          'يُستخدم عنصر Header في رسالة SOAP لتوفير معلومات إضافية مثل خيارات التوجيه وتفاصيل الأمان.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text': 'ما هي أنواع البيانات التي يدعمها SOAP؟',
      'choice1': 'فقط أنواع البيانات البدائية مثل integer و double',
      'choice2':
          'أنواع البيانات البدائية والمركبة مثل Node XML وDate Time، بالإضافة إلى المصفوفات',
      'choice3': 'أنواع البيانات النصية فقط',
      'choice4': 'أنواع البيانات الرسومية فقط',
      'correct_choice': 2,
      'reason':
          'يدعم SOAP العديد من أنواع البيانات، بما في ذلك البدائية والمركبة والمصفوفات، مما يجعله مرنًا في التعامل مع مختلف أنواع المعلومات.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text':
          'كيف يساعد البروكسي (Proxy) في تفاعل التطبيق مع خدمة ويب باستخدام SOAP؟',
      'choice1': 'يقوم بتشفير الرسائل بين التطبيق وخدمة الويب',
      'choice2': 'يساعد في نقل الطلبات والاستجابات بين التطبيق وخدمة الويب',
      'choice3': 'يخزن البيانات محليًا قبل إرسالها',
      'choice4': 'يحول البيانات إلى تنسيق HTML',
      'correct_choice': 2,
      'reason':
          'يعمل البروكسي كحلقة وصل بين التطبيق وخدمة الويب، مما يسهل نقل الطلبات والاستجابات بينهما.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text': 'لماذا يُعتبر SOAP خيارًا مفضلًا في تطوير خدمات الويب؟',
      'choice1': 'لأنه يعتمد على تقنية HTML',
      'choice2': 'لأنه يتعامل فقط مع أنواع البيانات النصية',
      'choice3':
          'لأنه يتيح تكامل الأنظمة بسهولة ويضمن تبادل المعلومات بطريقة موثوقة',
      'choice4': 'لأنه يُستخدم فقط في بيئات تطوير Microsoft',
      'correct_choice': 3,
      'reason':
          'SOAP يُعتبر خيارًا مفضلًا لأنه يتيح تكامل الأنظمة المختلفة بسهولة ويضمن تبادل المعلومات بطريقة موثوقة وآمنة.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text':
          'ما هو دور Visual Studio في تسهيل عملية الاتصال بين التطبيقات وخدمات الويب باستخدام SOAP؟',
      'choice1': 'توليد البروكسي تلقائيًا',
      'choice2': 'تحليل البيانات إلى رسومات بيانية',
      'choice3': 'إنشاء جدران نارية جديدة',
      'choice4': 'تشفير الرسائل بالكامل',
      'correct_choice': 1,
      'reason':
          'يسهل Visual Studio عملية الاتصال بين التطبيقات وخدمات الويب باستخدام SOAP عن طريق توليد البروكسي تلقائيًا.',
    });

    await db.insert('questions', {
      'test_id': 7,
      'question_text':
          'أي نوع من الرسائل يُرسل عند تفاعل التطبيق مع خدمة ويب باستخدام SOAP؟',
      'choice1': 'HTML Request',
      'choice2': 'SOAP Request',
      'choice3': 'JSON Request',
      'choice4': 'CSS Request',
      'correct_choice': 2,
      'reason':
          'يُرسل التطبيق طلبًا من نوع SOAP Request عند تفاعله مع خدمة ويب، مما يتضمن المعلومات اللازمة للطلب.',
    });
  }
}
